<?xml version="1.0" encoding="ISO-8859-1" ?>
<actions xmlVersion="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../schemas/action.xsd">

<!-- 

Copyright (C) 2014 - Gareth Edwards / Rapid Information Systems

gareth.edwards@rapid-is.co.uk


This file is part of the Rapid Application Platform

RapidSOA is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. The terms require you to include
the original copyright, and the license notice in all redistributions.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
in a file named "COPYING".  If not, see <http://www.gnu.org/licenses/>.

 -->

    <action>
        
        <type>dataCopy</type>
        <name>Data copy</name>	        
	    <class>com.rapid.actions.Datacopy</class>	 
	    
	    <addToNewApplications>true</addToNewApplications>
	    
	    <properties>
	        
	        <property>
	            <key>copyType</key>
	            <name>Copy type</name>
	            <setConstructValueFunction>return false;</setConstructValueFunction>
	            <changeValueJavaScript>select</changeValueJavaScript>	
	            <getValuesFunction>
// for backwards compatibility	                
if (!this.copyType) this.copyType = "replace";
// return the values	                
return [["replace","replace"],["append","append"],["row","row merge"],["child","child merge"],["bulk","bulk"],["search","search"],["trans","transpose"]];
				</getValuesFunction>
	            <refreshProperties>true</refreshProperties>	            
	        </property> 
	    
	        <property>
	            <key>dataSource</key>
	            <name>Source</name>
	            <changeValueJavaScript>datacopySource</changeValueJavaScript>
	            <getValuesFunction>
	                <![CDATA[
return "<option value=''>Please select...</option>" + getInputOptions(this.dataSource);         
	                ]]>
	            </getValuesFunction>	
	            <helpHtml>
	                <![CDATA[
<p>This powerful control moves data around your application. The following differnt types of data copy are supported:</p>
- replace, will empty the destination controls of data beore copying in the source data<br/>
- append, will add the source data as a new row in the destination data. Any existing fields will be used, new fields will be added<br/>
- row merge, will keep all destination data and add the source data in the same row. New fields will be added if required<br/>
- child merge, will uses fields in common between the source and destination to match rows in the source to rows in  the destination where matching rows in the source will be added to child datastores in the destination. Use this for parent/child relationships<br/> 
- bulk, provides a dialogue where a number of realted datacopies can easily be specified<br/>
- search, allows a source to be searched against a term and matching rows placed into the destination<br/>
- transpose, converts a source with lots of columns to one with lots of rows and vice versa. Key fields will appear on every row, igore fields will not be used in the transposition<br/>
	                ]]>
	            </helpHtml>
	        </property>
	        	        	      
	        <property>
	            <key>dataSourceField</key>
	            <name>Source field</name>
	            <changeValueJavaScript>datacopySourceField</changeValueJavaScript>
	            <getValuesFunction>return "";</getValuesFunction>
	        </property>	 
	        	        	        	        	        
	        <property>
	            <key>searchSource</key>
	            <name>Search term</name>
	            <changeValueJavaScript>datacopySearchSource</changeValueJavaScript>
	            <getValuesFunction>
	                <![CDATA[
return "<option value=''>Please select...</option>" + getInputOptions(this.dataSource);         
	                ]]>
	            </getValuesFunction>	
	        </property>
	        
	        <property>
	            <key>searchSourceField</key>
	            <name>Search term field</name>
	            <changeValueJavaScript>datacopySearchField</changeValueJavaScript>
	            <getValuesFunction>return "";</getValuesFunction>
	        </property>
	        
	        <property>
	            <key>searchField</key>
	            <name>Search fields</name>
	            <changeValueJavaScript>datacopySearchField</changeValueJavaScript>
	            <getValuesFunction>return "";</getValuesFunction>
	        </property>	
	        
	        <property>
	            <key>maxRows</key>
	            <name>Maximum rows</name>
	            <changeValueJavaScript>datacopyMaxRows</changeValueJavaScript>
	            <getValuesFunction>return "";</getValuesFunction>
	        </property>
	        	        	        
	        <property>
	            <key>dataDestinations</key>
	            <name>Destinations</name>
	            <changeValueJavaScript>datacopyDestinations</changeValueJavaScript> 
	            <refreshProperties>true</refreshProperties>
	        </property>
	        	         	        
	        <property>
	            <key>childField</key>
	            <name>Child field</name>
	            <changeValueJavaScript>datacopyChildField</changeValueJavaScript>
	            <getValuesFunction>return "";</getValuesFunction>
	        </property>
	        
	         <property>
	            <key>keyFields</key>
	            <name>Key fields</name>
	            <changeValueJavaScript>datacopyFields</changeValueJavaScript>
	            <getValuesFunction>return "";</getValuesFunction>
	            <refreshProperties>true</refreshProperties>
	        </property>		
	        
	         <property>
	            <key>ignoreFields</key>
	            <name>Ignore fields</name>
	            <changeValueJavaScript>datacopyFields</changeValueJavaScript>
	            <getValuesFunction>return "";</getValuesFunction>
	            <refreshProperties>true</refreshProperties>
	        </property>	
	        
	        <property>
	            <key>dataCopies</key>
	            <name>Bulk data copies</name>
	            <changeValueJavaScript>datacopyCopies</changeValueJavaScript>
	        </property>	
	        
	        <property>
	            <key>changeEvents</key>
	            <name>Trigger change events</name>
	            <changeValueJavaScript>checkbox</changeValueJavaScript>
	            <getValuesFunction>return false;</getValuesFunction>
	        </property>
	        	        	        	 	        	        	          
	    </properties>
	    	    
	    <actionJavaScript>
	        <![CDATA[ 
function Action_datacopy(ev, data, outputs, changeEvents, copyType, copyData, field, details) {
	if (data !== undefined && outputs) {
		for (var i in outputs) {
			var output = outputs[i];	
			var outputData = null;	
			switch (copyType) {
				case "append" :	case "row" : 
					var mergeData = window["getData_" + output.type](ev, output.id, null, output.details);
					data = makeDataObject(data, output.field);
					outputData = mergeDataObjects(mergeData, data, copyType, field); 
				break;
				case "child" :
					var mergeData = window["getData_" + output.type](ev, output.id, null, output.details);		
					if (data && data.rows) {								
						outputData = mergeDataObjects(mergeData, data, copyType, field);
					} else {
						outputData = mergeData;
					}
				break;
				case "search" :
					if (data) outputData = mergeDataObjects(copyData, data, copyType, field, details);
				break;
				case "trans" :						
					if (data && data.fields && data.rows) {	
												
						var downtoside = false;
						// checking for down to side transpose is quite expensive so get the easy stuff out the way first
						if (data.rows.length >= details.keyFields.length + 2) {
							var keyFieldsMap = {};
							for (var i in data.fields) {
								for (var j in details.keyFields) {
									if (data.fields[i] && details.keyFields[j] && data.fields[i].toLowerCase() == details.keyFields[j].toLowerCase()) {
										keyFieldsMap[i] = j;
										break;
									}
								}
							}
							if (Object.keys(keyFieldsMap).length == details.keyFields.length && data.fields.length >= details.keyFields.length + 2) {
								var keyValueCounts = {};
								for (var i in data.rows) {
									var keyValue = "";
									for (var j in keyFieldsMap) {
										keyValue += data.rows[i][keyFieldsMap[j]];
									}
									if (keyValueCounts[keyValue]) {
										keyValueCounts[keyValue] ++;
									} else {
										keyValueCounts[keyValue] = 1;
									}
									if (keyValueCounts[keyValue] > details.keyFields.length) {
										downtoside = true;
										break;
									}
								}
							}						
						}
												
						if (downtoside) {
							// transpose down to side
							var fieldPos = 0;
							var valuePos = 1;
							// check the map for whether the key fields are before or after the field/value pair
							if (for i in keyFieldsMap) {
								// if any of the key fields are in the first column
								if (i*1 == 0) {
									// change field and value columns from 1st and 2nd to those following the keys
									fieldPos = details.keyFields.length - 1;
									valuePos = details.keyFields.length;									
								}
							}
							var outputFields = [];
							for (var i in details.keyFields) outputFields.push(details.keyFields);
							var keyValueRows = {};
							for (var i in data.rows) {
								var row = data.rows[i];
								var field = row[fieldPos];
								var value = row[valuePos];
								// determin the key value for this row
								var keyValue = "";
								for (var j in keyFieldsMap) {
									keyValue += row[j];
								}
								// fetch the row we are creating for this key
								var keyRow = keyValueRows[keyValue];
								if (!keyRow) {
									keyRow = [];
									keyValueRows[keyValue] = keyRow;
								}
								// find the position of this field in the output fields
								var outputFieldPos = -1;
								for (var j in outputFields) {
									if (outputFields[j] == field) {
										outputFieldPos = j;
										break;
									}
								}
								// if the field couldn't be found
								if (outputFieldPos < 0) {
									outputFields.push(field);
									outputFieldPos = outputFields.length - 1;
								}
								// ensure the row is the right length as we discover more fields								
								while (keyRow.length < outputFields.length) keyRow.push(null);
								// set the value in the correct position
								keyRow[outputFieldPos] = value;
																													 
							}
							outputData = {fields:outputFields,rows:[]};		
							for (var i in keyValueRows) outputData.rows.push(keyValueRows[i]);
						} else {
							// transpose side to down				
							outputData = {fields:["field","value"],rows:[]};						
							if (details && details.keyFields && details.keyFields.length > 0) {
								for (var j in details.keyFields) {
									outputData.fields.push(details.keyFields[j]);
								}
							}						
							for (var i in data.rows) {						
								var keyFieldValues = [];						
								// key fields
								if (details && details.keyFields && details.keyFields.length > 0) {
									for (var j in details.keyFields) {
										for (var k in data.fields) {
											if (data.fields[k] && details.keyFields[j].toLowerCase() == data.fields[k].toLowerCase()) {
												keyFieldValues.push(data.rows[i][k]);
												break;
											}
										}
									}								
								}
																																		
								// values
								for (var j in data.fields) {
									var ignore = false;
									if (details && details.ignoreFields && details.ignoreFields.length > 0) {
										for (var k in details.ignoreFields) {
											if (!data.fields[j] || data.fields[j].toLowerCase() == details.ignoreFields[k].toLowerCase()) {
												ignore = true;
												break;
											}
										}
									}
									if (!ignore) {
										var row = [data.fields[j],data.rows[i][j]];
										for (var k in keyFieldValues) row.push(keyFieldValues[k]);
										outputData.rows.push(row);
									}
								}																											
							}
						}
					}
				break;
				default:
					outputData = data;
			}	
			window["setData_" + output.type](ev, output.id, output.field, output.details, outputData, changeEvents);
		}
	}
}	        ]]>
	    </actionJavaScript>
	    	    	    	    
    </action>     
</actions>