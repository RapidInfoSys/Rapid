<?xml version="1.0" encoding="ISO-8859-1" ?>
<controls xmlVersion="2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../schemas/control.xsd">

<!-- 

Copyright (C) 2017 - Gareth Edwards / Rapid Information Systems

gareth.edwards@rapid-is.co.uk


This file is part of the Rapid Application Platform

Rapid is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. The terms require you to include
the original copyright, and the license notice in all redistributions.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
in a file named "COPYING".  If not, see <http://www.gnu.org/licenses/>.

 -->
 
	<control>
	
	    <type>grid</type>
	    <name>Grid</name>
	    <image>images/grid_24x24.png</image>
	    <helpHtml>This control will generate a grid on the page. Grids are useful for displaying data that has been injected into it, and work especially well with the datastore control and the button control.</helpHtml>
	    
	    <addToNewApplications>true</addToNewApplications>
	          
	    <canUserAdd>true</canUserAdd>
	    <canUserMove>true</canUserMove>
	    <canUserAddPeers>true</canUserAddPeers>
	    
	    <properties>
	        
	        <property>
	            <key>name</key>
	            <name>Name</name>
	            <changeValueJavaScript>text</changeValueJavaScript>
	            <helpHtml>Name that can be given to the control. Names are used to help identify controls uniquely.</helpHtml>
	        </property>
	                    
	        <property>
	            <key>columnHeadings</key>
	            <name>Column headings</name>
	            <setConstructValueFunction>return true;</setConstructValueFunction>
	            <changeValueJavaScript>checkbox</changeValueJavaScript>
	            <refreshHtml>true</refreshHtml>
	            <helpHtml>Sets whether the grid will use headings or not.</helpHtml>
	        </property>
	        
	        <property>
	            <key>columns</key>
	            <name>Columns</name>
	            <setConstructValueFunction>return [];</setConstructValueFunction>
	            <changeValueJavaScript>gridColumns</changeValueJavaScript>
	            <refreshHtml>true</refreshHtml>
	            <helpHtml>Sets the different columns to be used by the grid. Multiple can be set or removed here and each can be customised.</helpHtml>
	        </property>
	        
	        <property>
	            <key>multiSelect</key>
	            <name>Multi-select?</name>
	            <setConstructValueFunction>return false;</setConstructValueFunction>
	            <changeValueJavaScript>checkbox</changeValueJavaScript>
	            <refreshHtml>true</refreshHtml>
	            <helpHtml>Whether to show a first column of checkboxes to allow multiple rows in the grid to be selected.</helpHtml>
	        </property>
	        
	        <property>
	            <key>dataStorageType</key>
	            <name>Data store type</name>
	            <setConstructValueFunction>return "";</setConstructValueFunction>
	            <changeValueJavaScript>select</changeValueJavaScript>
	            <getValuesFunction>
	                <![CDATA[
return [["","None"],["L","Local storage"],["S","Session storage"],["P","Page storage"]];
					]]>
	            </getValuesFunction>
	            <helpHtml>Sets the method of data storage. Page storage is for as long as the page is open, session is for as long as the tab/window is open and local is for files to be stored locally on devices.</helpHtml>
	        </property>
	        
	        <property>
	            <key>scrollH</key>
	            <name>Scroll horizontal</name>
	            <setConstructValueFunction>return "";</setConstructValueFunction>
	            <changeValueJavaScript>select</changeValueJavaScript>
	            <getValuesFunction>
	                <![CDATA[
return [["","No"],["scroll","Yes"],["auto","Auto"]];
					]]>
	            </getValuesFunction>
	            <refreshHtml>true</refreshHtml>
	            <refreshProperties>true</refreshProperties>
	            <helpHtml>Sets the horizontal scrollbar.</helpHtml>
	        </property> 
	        
	        <property>
	            <key>scrollWidth</key>
	            <name>Width</name>
	            <changeValueJavaScript>gridScrollWidth</changeValueJavaScript>
	             <refreshHtml>true</refreshHtml>
	        </property>
	        
	        <property>
	            <key>scrollV</key>
	            <name>Scroll vertical</name>
	            <setConstructValueFunction>return "";</setConstructValueFunction>
	            <changeValueJavaScript>select</changeValueJavaScript>
	            <getValuesFunction>
	                <![CDATA[
return [["","No"],["scroll","Yes"],["auto","Auto"]];
					]]>
	            </getValuesFunction>
	            <refreshHtml>true</refreshHtml>
	            <refreshProperties>true</refreshProperties>
	            <helpHtml>Sets the vertical scrollbar.</helpHtml>
	        </property>
	        
	        <property>
	            <key>scrollHeight</key>
	            <name>Height</name>
	            <changeValueJavaScript>gridScrollHeight</changeValueJavaScript>	         
	             <refreshHtml>true</refreshHtml>   
	        </property>	
	        
	        <property>
	            <key>fixedHeader</key>
	            <name>Fixed header</name>
	            <changeValueJavaScript>gridScrollFixedHeader</changeValueJavaScript>	           
	             <refreshHtml>true</refreshHtml> 
	        </property>	
	         
	    </properties>
	    
	    <resources>
	        
	        <resource>	            
	            <type>cssFile</type>
	            <contents>styles/fonts/fontawesome/css/font-awesome.css</contents>
	        </resource>
	        
	        <!-- Some browsers choose the tff instead of the woff so both are included -->
	        <resource>	            
	            <type>file</type>
	            <contents>styles/fonts/fontawesome/fonts/fontawesome-webfont.woff</contents>
	        </resource>
	        
	        <resource>
	            <type>file</type>
	            <contents>styles/fonts/fontawesome/fonts/fontawesome-webfont.ttf</contents>
	        </resource>
	        
	        <resource>
	            <type>css</type>
	            <contents>
	                <![CDATA[	                
table.grid {
	border-collapse:collapse;
}          

table.grid td {
	border: 0;
}     

table.grid span.sort {
	font-family: FontAwesome;
	margin-left: 5px;
}

div.gridScroll {
	display: inline-block;
}

div.gridScroll table {
	width: 100%;
}

div.gridScrollHeader {
	overflow-y: hidden;
}

div.gridScrollHeader table {
	width: calc(100% - 16px) !important;	
}

div.gridScrollHeader table.grid tr:not(:first-child) {
	visibility: hidden;
}

div.gridScrollBody table.grid tr:first-child {
	visibility: hidden;
}
	                ]]>
				</contents>
	        </resource>
	        
	        <resource>
	            <type>javascript</type>
	            <contents>
	                <![CDATA[
	                
function getGridDataStoreData(id, details) {
	data = null;
	dataString = null;
	switch (details.dataStorageType) {
		case "L" :
			dataString = localStorage[_appId + id];
		break;
		case "S" :
			dataString = sessionStorage[_appId + id];
		break;
		case "P" :
			dataString = window[_appId + "datastore"];			
		break;
	}
	if (dataString) {
		data = JSON.parse(dataString);
		if (data) {
			if (!data.fields) data.fields = [];
			if (!data.rows) data.rows = [];
		}
	}
	return data;
}

function saveGridDataStoreData(id, details, data) {
	switch (details.dataStorageType) {
		case "L" :
			localStorage[_appId + id] = JSON.stringify(data);
		break;
		case "S" :		
			sessionStorage[_appId + id] = JSON.stringify(data);
		break;
		case "P" :
			window[_appId + "datastore"] = JSON.stringify(data);
		break;
	}
}	

function sortGridByColumn(ev, id, details, column, asc) {

	// check we have details and this column
	if (details && details.columns && details.columns[column]) {

		// get the grid data
		var data = getData_grid(ev, id, null, details);
			
		// get the field
		var field = details.columns[column].field;
		
		// assume data and details columns are the same
		var dataColumn = column;
		
		// check the column matches the field
		if (data.fields[column] != field) {
			// didn't match so find what it should be
			for (var i in data.fields) {
				if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
					dataColumn = i;
					break;
				}
			}	
		}
	
		// check there is data for the column
		if (data && data.rows && data.fields[dataColumn]) {
		
			// an array for all values in this column
			var sortedValues = [];
			// populate the array for each row with an object with the original index and value
			for (var i in data.rows) sortedValues.push( {index:i, value:data.rows[i][dataColumn]} );
			// determin the sort type
			switch (details.columns[column].sort) {
				// for n, turn both values into numbers and use that
				case "n" : sortedValues.sort( function(i1, i2) {
					var v1 = i1.value;
					if (v1) v1 = parseFloat(v1.replace(",",""));
					var v2 = i2.value;
					if (v2) v2 = parseFloat(v2.replace(",",""));
					return v1 - v2; 
				});			
				break;
				// d1 is uk date format
				case "d1": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("/");
					var d2Parts = i2.value.split("/");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						var d1 = new Date(d1Parts[2], d1Parts[1]-1, d1Parts[0]);
						var d2 = new Date(d2Parts[2], d2Parts[1]-1, d2Parts[0]);
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d2 is uk month-word date format
				case "d2": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("-");
					var d2Parts = i2.value.split("-");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						var months = ["jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec"];
						for (m1 in months) if (d1Parts[1].toLowerCase().substr(0,3) == months[m1]) break;
						for (m2 in months) if (d2Parts[1].toLowerCase().substr(0,3) == months[m2]) break;
						var d1 = new Date(d1Parts[2], m1, d1Parts[0]);
						var d2 = new Date(d2Parts[2], m2, d2Parts[0]);
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d3 is us date format
				case "d3": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("/");
					var d2Parts = i2.value.split("/");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						var d1 = new Date(d1Parts[2], d1Parts[0]-1, d1Parts[1]);
						var d2 = new Date(d2Parts[2], d2Parts[0]-1, d2Parts[1]);
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d4 is xml date format
				case "d1": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("-");
					var d2Parts = i2.value.split("-");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						var d1 = new Date(d1Parts[0], d1Parts[1]-1, d1Parts[1]);
						var d2 = new Date(d2Parts[0], d2Parts[1]-1, d2Parts[1]);
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// for c, make a new function from the sortFunction property and use that
				case "c":
					var f = new Function("item1","item2",details.columns[column].sortFunction);
					sortedValues.sort(f);				
				break;
				default : sortedValues.sort( function(i1, i2) {				
					// easy one's first
					if (i1.value == null) {				
						return 1;
					} else if (i2.value == null) {
						return -1;
					} else {
						// assume the values match
						var s = 0;
						// get both values in lower case
						v1 = i1.value.toLowerCase();
						v2 = i2.value.toLowerCase();
						// only if the two are different
						if (v1 != v2) {			
								// get the shortest length
								var l = Math.min(v1.length, v2.length);
								// loop the shortest length
								for (var i = 0; i < l; i++) {
									// check the different in ascii values
									if (v1.charCodeAt(i) > v2.charCodeAt(i)) {
										s = 1;
										break;
									} else if (v1.charCodeAt(i) < v2.charCodeAt(i)) {
										s = -1;
										break;
									}					
								}
								// if s is still zero use the length of the strings
								if (s == 0) s = v1.length - v2.length;			
						} // same check
						return s
					} // null checks					
				}); 
			}
					
			// create a new rows array
			var rows = [];
			// if asc
			if (asc) {
				// loop the returned sorted column values and add into the rows array from their original position
				for (var i in sortedValues)  rows.push(data.rows[sortedValues[i].index]);
			} else {
				// loop the returned sorted column values in reverse  and add into the rows array from their original position
				for (var i in sortedValues)  rows.push(data.rows[sortedValues[sortedValues.length - i - 1].index]);
			}
			// replace the data rows with the placed rows
			data.rows = rows;
			// set the sorted data
			setData_grid(ev, id, null, details, data);
		}
	}
} 

// get the index of the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridSelectedRowNumber(id, ev) {
	// assume we're not going to find it
	var index = -1;
	// get the target of the event
	var target = $(ev.target);
	// look for whether the target was in a grid row
	var row = target.closest("tr.rowStyle1,tr.rowStyle2");
	// check if in a row
	if (row[0]) {
		// the event occured from within a row so find the table, and the index of the row from the official rows
		var rows = row.closest("table").find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]");
		// if this was a row to be ignored, find the previous most non-ignored row
		if (row.is("[data-ignore]")) row = row.prevAll("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").first();
		// get the position of relevant row
		index = rows.index(row);		
	} else {
		// the event occured outside a row so get the table using the id
		var grid = $("#" + id);
		// make sure it's a table
		if (!grid.is("table")) grid = grid.find("table").last();
		// index is the row with the selected style within the grid
		index = grid.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").index(grid.find("tr.rowSelect"));			
	}
	if (index > -1) index ++;
	return index;
}

// gets the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridSelectedRow(id, ev) {
	// assume we're not going to find it
	var row = null;
	// get the target of the event
	var target = $(ev.target);
	// look for whether the target was in a grid row
	var row = target.closest("tr.rowStyle1,tr.rowStyle2");
	// check if in a row
	if (row[0]) {
		// the event occured from within a row so find the table, and the index of the row from the official rows
		var rows = row.closest("table").find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]");
		// if this was a row to be ignored, find the previous most non-ignored row
		if (row.is("[data-ignore]")) row = row.prevAll("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").first();
	} else {
		// the event occured outside a row so get the table using the id
		var grid = $("#" + id);
		// make sure it's a table
		if (!grid.is("table")) grid = grid.find("table").last();
		// row is .rowSelect
		row = grid.find("tr.rowSelect").not("[data-ignore]");			
	}
	return row;
}

// gets the selected rows, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridMutiSelectedRows(id, ev) {
	// assume we're not going to find any
	var rows = null;
	// get the grid
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// rows have .rowSelect and not data-ignore
	rows = grid.find("tr.rowSelect").not("[data-ignore]");			
	// return
	return rows;
}
           	
	                ]]>
	            </contents>
	        </resource>
	    </resources>
	    
	    <getHtmlFunction>
	        <![CDATA[ 
var headerHtml = "<tr" + (this.columnHeadings ? "" : " style='display:none;'") + ">";
var rowHtml = "<tr><td>No columns</td></tr>";
if (this.columns.length > 0) {
	var rowHtml = "<tr>";
	if (this.multiSelect) {
		headerHtml += "<td><input type='checkbox' class='gridMultiSelectHeader'/></td>";
		rowHtml += "<td><input type='checkbox' class='gridMultiSelect'/></td>";
	}
	var columnCount = 0;
	for (var i in this.columns) {
		var column = this.columns[i];
		if (column.visible) {
			headerHtml += "<td" + (column.titleStyle ? " style='" + escapeApos(column.titleStyle) + "'" : "") + ">" + column.title;
			if (column.sort) headerHtml += "<span class='sort'>&#xf0dc;</span>";
			headerHtml += "</td>";
			if (i % 2 == 1) {
			 	rowHtml += "<td " + (column.fieldStyle ? " style='" + escapeApos(column.fieldStyle) + "'" : "") + ">123.00</td>"
			} else {
				rowHtml += "<td" + (column.fieldStyle ? " style='" + escapeApos(column.fieldStyle) + "'" : "") + ">Data</td>"
			}
			columnCount ++;
		} else {
			headerHtml += "<td style='display:none;'>" + column.title + "</td>";
			rowHtml += "<td style='display:none;'></td>"
		}
	}
	if (columnCount == 0) {
		headerHtml += "<td>No visible columns</td>"
		rowHtml += "<td>No visible columns</td>";
	}
	headerHtml += "</tr>";
	rowHtml += "</tr>";
} else {
	headerHtml += "<td>No columns</td>"
}

// if details and headerHeight, retain in the designer
if (this.details) {
	// if it's still a string parse it from JSON
	if (typeof this.details === 'string' || this.details instanceof String) this.details = JSON.parse(this.details);
	// if there is a headerHeight keep it in the window
	if (this.details.headerHeight) window[this.id + "headerHeight"] = this.details.headerHeight;
}
	                
// check for scrolling
if (this.scrollH || this.scrollV) {
	// return a container div with the table inside
	return "<div id='" + this.id + "' style='display:inline-block;" + (this.scrollH ? "overflow-x:" + this.scrollH + ";max-width:" + this.scrollWidth + ";" : "") + "' class='gridScroll" + getStyleClasses(this) + "'><table class='grid'>" + headerHtml + rowHtml.replace("<tr>","<tr class='rowStyle1'>") + rowHtml.replace("<tr>","<tr class='rowStyle2'>") + "</table></div>";
} else {
	// return a simple table
	return "<table id='" + this.id + "' class='grid" + getStyleClasses(this) + "'>" + headerHtml + rowHtml.replace("<tr>","<tr class='rowStyle1'>") + rowHtml.replace("<tr>","<tr class='rowStyle2'>") + "</table>";
}
	        ]]>
	    </getHtmlFunction>
 	    
	   <initDesignJavaScript>
	   		<![CDATA[
// upgrade any previous version styles to this version to include the header
if (this.styles && this.styles.length > 0) {
	// get the id
	var id = this.id;
	for (var i =0; i < this.styles.length; i++) {
		// get the style
		var style = this.styles[i];
		// if this is one to upgrade do so
		if (style.appliesTo == "#" + id) this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header", rules: style.rules});
		if (style.appliesTo == "#" + id + " tr:first-child") this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header tr:first-child", rules: style.rules});
		if (style.appliesTo == "#" + id + " tr:first-child td") this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header tr:first-child td", rules: style.rules});
	}
}
	   		]]>
	   </initDesignJavaScript>
	   
	    <saveJavaScript>
	        <![CDATA[
var table = this.object;
if (!table.is("table")) table = table.find("table").last();
// remove all sample rows, leaving the header row
table.children().last().children(":not(:first)").remove();	        
	        ]]>
	    </saveJavaScript>
	    
	    <getDetailsFunction>	        
	        <![CDATA[
var details = {type: this.type};
if (this.columns && this.columns.length > 0) {
	details.columns = [];
	for (var i in this.columns) {
		var column = this.columns[i];
		var c = {};
		if (column.visible) c.visible = column.visible;
		if (column.field) c.field = column.field;
		if (column.fieldStyle) c.style = column.fieldStyle;		
		if (column.sort) c.sort = column.sort;
		if (column.sortFunction) c.sortFunction = column.sortFunction;
		if (column.cellFunction) c.cellFunction = column.cellFunction;			
		details.columns.push(c);
	}
} 	        
if (this.styles && this.styles.length > 0) {
	details.rowHover = false;
	details.rowSelect = false;
	for (var i in this.styles) {
		var style = this.styles[i];
		if (style.appliesTo && style.appliesTo.indexOf("rowHover") > 0) details.rowHover = true;
		if (style.appliesTo && style.appliesTo.indexOf("rowSelect") > 0) details.rowSelect = true;
	}
}
// set multiSelect
if (this.multiSelect) details.multiSelect = true;
// check and set data storage
if (this.dataStorageType) {
	this.canBeUsedFromOtherPages = true;
	details.dataStorageType = this.dataStorageType;
} else {
	this.canBeUsedFromOtherPages = false;
}
// if scrollH set header and width
if (this.scrollH) {
	details.scrollH = this.scrollH;
	details.scrollWidth = this.scrollWidth;
}
// if scrollV set scroll, height, and header
if (this.scrollV) {
	details.scrollV = this.scrollV;
	details.scrollHeight = this.scrollHeight;
	details.fixedHeader = this.fixedHeader;

	// assume no headerHeight
	var headerHeight = 0;
	// get the control
	var control = this.object;
	// if visible
	if (control.is(":visible")) {
		// get the first row
		var headerRow = control.find("tr").first();		
		// retain this in the window as this might be called again when it's not visible
		window[this.id + "headerHeight"] = headerRow.height();
	}
	// read any headerHeight set previously
	headerHeight = window[this.id + "headerHeight"]
	// add to details if we got one
	if (headerHeight) details.headerHeight = headerHeight;	
}
return details;
			]]>	        	        
	    </getDetailsFunction>
	    
	    <getDataFunction>
	        <![CDATA[
var data = null;
if (details) {
	// if there is a datastore and the grid is not present in the page    
	if (details.dataStorageType && !$("#" + id)[0]) {
		data = getGridDataStoreData(id, details);
		if (field && data.fields && data.rows && data.rows.length > 0) {
			for (var i in data.fields) {
				if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
					data = data.rows[0][i];
					break;
				}
			}
		}
	} else if (details.columns) {
		if (field) {		
			var row = getGridSelectedRow(id, ev);
			if (row[0]) {
				for (var i in details.columns) {
					if (details.columns[i].field && details.columns[i].field.toLowerCase() == field.toLowerCase()) {
						data = row.children(":nth(" + i + ")").html();
						break;
					}
				}
			}	    
			if (data == null && details.dataStorageType) {
				var dataStore = getGridDataStoreData(id, details);
				var rowIndex = getGridSelectedRowNumber(id, ev);
				rowIndex --;
				if (rowIndex > -1 && dataStore.rows && dataStore.rows.length > rowIndex) {
					for (var i in dataStore.fields) {
						if (dataStore.fields[i] && dataStore.fields[i].toLowerCase() == field.toLowerCase()) {
							data = dataStore.rows[rowIndex][i];
							break;
						}
					}
				}
			}
		} else {
			var data = {};
			data.fields = [];		
			for (var i in details.columns) {
				var field = details.columns[i].field;
				if (field) data.fields.push(details.columns[i].field);		
			}
			data.rows = [];
			var table = $("#" + id);
			if (!table.is("table")) table = table.find("table").last();
			table.find("tr:not(:first):not([data-ignore])").each(function(i) {
				var row = [];
				$(this).children().each(function(i) {
					if (details.columns[i].field) row.push($(this).html());
				});
				data.rows.push(row);
			});
			// if there is a data store
			if (details.dataStorageType) {
			    // get the data from the data store
				var dataStore = getGridDataStoreData(id, details);
				// if we got one
				if (dataStore) {
					// make a field map of data from the grid to data from the dataStore
					var fieldMap = {};
					// loop the fields from the control in the page
					for (var i in data.fields) {
						// assume we can't find this field
						var found = false;
						// loop the fields from the dataStore
						for (var j in dataStore.fields) {
							// if this is the field they both have
							if (data.fields[i] && dataStore.fields[j] && data.fields[i].toLowerCase() == dataStore.fields[j].toLowerCase()) {
								fieldMap[i] = j;
								found = true;
								break;
							}							
						}
						// if not found 
						if (!found) {
							//add to dataStore fields
							dataStore.fields.push(data.fields[i]);
							// add to map
							fieldMap[i] = dataStore.fields.length - 1;
						}	
					}
					// loop the rows in the data from the grid
					for (var i in data.rows) {
						// add an empty row to the dataStore rows if there are more in the page
						if (dataStore.rows.length < i - 1) dataStore.rows.push([]);
						// if there are less cells in the rows than it's fields add more
						while (dataStore.rows[i].length < dataStore.fields.length) dataStore.rows[i].push(null);						
						// loop the fieldMap and update dataStore with values from page
						for (j in fieldMap) dataStore.rows[i][fieldMap[j]] = data.rows[i][j];						
					}
					// set data to our merged dataStore
					data = dataStore;	
				}							
			}						
		}	
	}
}
return data;
			]]>
	    </getDataFunction>	   
	    	    	   
	    <setDataJavaScript>
	        <![CDATA[
// get the grid control	        
var control = $("#" + id);
// make sure it's a table
if (!control.is("table")) control = control.find("table").last();
// remove all rows except for the first one
control.find("tr:not(:first-child)").remove();	        
// reset any sort indicators if not being used for sorting
control.find("span.sort").html("&#xf0dc");
// if we have data
if (data !== undefined) {

	data = makeDataObject(data, field);
	if (data && data.rows) {	        		
		if (details && details.columns && data.fields) {
			var columnMap = [];
			for (var i in details.columns) {				
				for (var j in data.fields) {
					var found = false;
					if (details.columns[i].field && data.fields[j]) {
						if (details.columns[i].field.toLowerCase() == data.fields[j].toLowerCase()) found = true;
					} else {
						if (!data.fields[j]) found = true;
					}
					if (found) {
						columnMap.push(j);
						break;
					}
				}
				// added the column to the map
				if (columnMap.length == i) columnMap.push("");
				// if we have cellFunction JavaScript, and it hasn't been turned into a function object yet
				if (details.columns[i].cellFunction && !details.columns[i].f) details.columns[i].f = new Function(["id", "data", "field", "details", "value"],details.columns[i].cellFunction);
			}
			for (var i in data.rows) {
				var row = data.rows[i];
				var rowObject = control.append("<tr class='rowStyle" + (i % 2 + 1) + "'></tr>").find("tr:last");
				// add multiselect
				if (details.multiSelect) rowObject.append("<td><input type='checkbox' class='gridMultiSelect' /></td>");
				// loop colummns
				for (var j in details.columns) {
					var style = "";
					if (!details.columns[j].visible) style += "display:none;";
					if (details.columns[j].style) style += details.columns[j].style;
					if (style) style = " style='" + style + "'";
					// assume the cell has no value
					var value = "";				
					// get the position of this column in the data object
					var mappedCol = columnMap[j];
					// if we can find the column and it has data use it as the value
					if (mappedCol && row[mappedCol] !== null) value = row[columnMap[j]];
					// add the cell with the value and return a reference
					var cellObject = rowObject.append("<td" + style + ">" + value + "</td>").children("td:last");
					// apply any cell function
					if (details.columns[j].f) {
						details.columns[j].f.apply(cellObject,[id, data, field, details, value]);
					}
				}		
				// if there is a rowValidation collection
				if (data.rowValidation && i < data.rowValidation.length) {
					if (!data.rowValidation[i]) rowObject.addClass("validation");
				}		
			}
			// if there is a selected row
			if (data.selectedRowNumber) control.find("tr:nth(" + data.selectedRowNumber + ")").addClass("rowSelect");
		} else {
			for (var i in data.rows) {
				// add a row object with the styling
				var rowObject = control.append("<tr class='rowStyle" + (i % 2 + 1) + "'></tr>").find("tr:last");
				// get the row
				var row = data.rows[i];
				// loop the row cells				
				for (var j in row) {
					// add cell with value to row
					rowObject.append("<td" + style + ">" + row[j] + "</td>");
				}
			}
		} // got details and columns and data fields							
	} // got data
	if (details && details.dataStorageType) saveGridDataStoreData(id, details, data);
		
	// if we vertical scrolling
	if (details && details.scrollV && details.scrollHeight) {
	
		// if we have a fixed header
		if (details.fixedHeader) {
		
			// if we haven't applied it yet
			if (!control.parent().is(".gridScrollBody")) {
		
			    // create and style the wrapper
			    var oTblDiv = $("<div class='gridScrollBody' />");
			    oTblDiv.css({
			    	"max-height": details.scrollHeight,
			    	"overflow-y": details.scrollV
			    });
			    // wrap it
			    control.wrap(oTblDiv);

			    // save original column widths			    			    
			    control.find('thead tr td').each(function(){
			        $(this).attr("data-item-original-width",$(this).width());
			    }); 
			    control.find('tbody tr:eq(0) td').each(function(){
			        $(this).attr("data-item-original-width",$(this).width());
			    });                 
			
			    // clone the original table
			    var newTbl = control.clone();
			    // update it's id
			    newTbl.attr("id",id + "header");
			    				
				// set the class on the parent on the new table (this is the control root)
			    newTbl.parent().addClass("gridScroll");	      
				// get the old table parent
			    var parent = control.parent();
				// add the new table
			    parent.parent().prepend(newTbl);			    
			    // move the old table parent after the new table
			    parent.insertAfter(newTbl);
			    // wrap the new table
			    newTbl.wrap("<div class='gridScrollHeader' />")
			    				    			
			    // replace original column widths
			    newTbl.find('thead tr td').each(function(){
			        $(this).width($(this).attr("data-item-original-width"));
			    });     
			    control.width(control.attr('data-item-original-width'));      
			    control.find('tbody tr:eq(0) td').each(function(){
			        $(this).width($(this).attr("data-item-original-width"));
			    });
			    
			    // get the header hight
			    var headerHeight = newTbl.find("tr:first-child").height();
			    // if the headerHeight is 0 this table is probably not visible use what we have in the details
			    if (headerHeight == 0 && details.headerHeight) headerHeight = details.headerHeight;
			    // set height of the header table wrapper
			    newTbl.parent().css({"height":headerHeight});
			    // shift the new table up behind the fixed header
			    control.css("margin-top",-headerHeight);
			    
			} // fixed header applied
		    
		} else {
		
			// check not applied already
			if (!control.parent().is(".gridScrollApplied")) {

				// remove the table id
				control.removeAttr("id")
				// create and style the wrapper
			    var oTblDiv = $("<div class='gridScroll' id='" + id + "' />");
			    oTblDiv.css({
			    	"height": details.scrollHeight,
			    	"overflow-y": details.scrollV
			    });
			    // retain that we have applied the scroll
			    oTblDiv.addClass("gridScrollApplied");
			    // wrap it
			    control.wrap(oTblDiv);
			    
			} // v scroll applied check
		
		} // fixed header
				
	} // vertical scrolling
	
	// if we have multiSelect
	if (details.multiSelect) {
		// fixed header clones the header and the checkbox in it so we need to put the header checbox listener back
		if (details.scrollV && details.scrollHeight && details.fixedHeader) {
			$("#" + id).find("input.gridMultiSelectHeader").first().change(function(ev){
				// get the header value
				var select = $(this).prop("checked");
				// update rowSelect accordingly
				if (select) {
					control.find("tr").addClass("rowSelect");
				} else {
					control.find("tr").removeClass("rowSelect");
				}
				// update row checkboxes
				control.find("input.gridMultiSelect").prop("checked",select);
			});
		}
		// listen for rows checkbox - needs to be click to beat the listener on the row
		control.find("input.gridMultiSelect").click(function(ev){
			// get the input
			var i = $(this);
			// get the value
			var select = i.prop("checked");
			// add or remove class accordingly
			if (select) {
				i.closest("tr").addClass("rowSelect");
			} else {
				i.closest("tr").removeClass("rowSelect");
			}
			// check whether any rows without rowSelect, if not uncheck header checkboxs (includes if fixed header)
			if (control.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").not(".rowSelect").length > 0) $("#" + id).find("input.gridMultiSelectHeader").prop("checked",false);
			// stop the row click event firing
			ev.stopPropagation();
		});
	
	} else {
		// if we click on a row that isn't the first one
		control.children().last().children("tr:not(:first)").click( function() {
			// get the row 
			var row = $(this);
			// remove rowSelect class from all rows in the table
			row.parent().find("tr.rowSelect").removeClass("rowSelect");
			// add rowSelect to this row
			row.addClass("rowSelect"); 
		});
	}
	
	// apply the resizing	
	$(window).resize(); 
	
}
			]]>
	    </setDataJavaScript>
	    
	    <events>
	        <event>
	            <type>click</type>
	            <name>Row click</name>
	            <filterFunction>
<![CDATA[
var target = $(ev.target);
// don't fire if the target is the top row or tbody
if (target.closest("tr").index() == 0 || target.is("tbody")) return false;
]]>	                
	            </filterFunction>
	        </event>
	    </events> 
	    
	    <styles>
	        <style>
	            <name>Grid</name>  
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + ", #" + this.id + "header";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Title row</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:first-child, #" + this.id + "header tr:first-child";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Title cells</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:first-child td, #" + this.id + "header tr:first-child td";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Row cells</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:not(:first-child) td";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Row style 1</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowStyle1";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Row style 2</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowStyle2";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Row hover</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:hover:not(:first-child)";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>	 
	        <style>
	            <name>Row select</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowSelect";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>       
	    </styles>
	    
	    <initJavaScript>
	        <![CDATA[
// get the control
var control = $("#" + id);
// make sure it's a table
if (!control.is("table")) control = control.find("table").last();     
// check there are details	        
if (details) {
	// if there are columns
	if (details.columns) {				
		// get the header cells
		var headers = control.find("tr:first-child td");
		// loop the columns
		for (var i in details.columns) {
			// if it has a sort
			if (details.columns[i].sort) {
				// get the header cell
				var cell = $(headers.get(i));
				// change the cursor
				cell.css("cursor","pointer");
				// add a listener
				cell.click( {index:i},function(ev) {
					// get the span
					var span = $(ev.target);
					// drill down if need be
					if (!span.is("span")) span = span.find("span");
					// if ascending or not set (note the unicode escape)
					if (span.html() == "\uf0de") {
						sortGridByColumn(ev, id, details, ev.data.index, false);
						span.html("&#xf0dd;");
					} else {
						sortGridByColumn(ev, id, details, ev.data.index, true);
						span.html("&#xf0de;");
					}
				});
			}
		}
	}
	// if this is multiSelect, set up the header listener
	if (details.multiSelect) {
		control.find("input.gridMultiSelectHeader").change(function(ev){
			// get the header value
			var select = $(this).prop("checked");
			// update rowSelect accordingly
			if (select) {
				control.find("tr").addClass("rowSelect");
			} else {
				control.find("tr").removeClass("rowSelect");
			}
			// update row checkboxes
			control.find("input.gridMultiSelect").prop("checked",select);
		});
	}
	// if there is a data store
	if (details.dataStorageType) {
		var data = getGridDataStoreData(id, details);
		if (data) setData_grid($.Event('gridinit'), id, null, details, data);
		$("#" + id).click( function(ev) {
			var data = getGridDataStoreData(id, details);
			data.selectedRowNumber = getGridSelectedRowNumber(id, ev);
			saveGridDataStoreData(id, details, data);
		});
	} // datastorage type check
} 
	        ]]>	        
	    </initJavaScript>
	    
	    <runtimeProperties>
	        
	        <runtimeProperty>
	   	        <type>selectedRowData</type>
	   	        <name>Selected row data</name>
	   	        <getPropertyFunction>
			        <![CDATA[
var data = null;
if (details.dataStorageType) {
	data = getGridDataStoreData(id, details);	
	var grid = $("#" + id);
	if (!grid.is("table")) grid = grid.find("table").last();
	if (grid[0]) {
		var rowNumber = getGridSelectedRowNumber(id, ev);
		if (rowNumber != data.selectedRowNumber) {
			data.selectedRowNumber = rowNumber;
			saveGridDataStoreData(id, details, data);
		}
	}
	if (data.selectedRowNumber) {
		data.rows = [data.rows[data.selectedRowNumber - 1]];
	} else {
		data.rows = [];
	}
} else {
	if (details.multiSelect) {
		var rows = getGridMutiSelectedRows(id, ev);
		if (rows && rows.length > 0) {
			data = {fields:[],rows:[]};
			for (var i = 0; i < rows.length; i++) {
				// get a jQuery wrapper for the row element
				var row = $(rows[i]);
				// prepare a data row
				var dataRow = [];
				// loop the columns
				for (var j = 0; j < details.columns.length; j++) {
					// add fields once only
					if (i == 0) data.fields.push(details.columns[j].field);
					// add cell html to datarow - one over because of the checkbox
					dataRow.push(row.children(":nth(" + (j + 1) + ")").html());
				}
				// add datarow to row
				data.rows.push(dataRow);
			}
		}
	} else {
		var row = getGridSelectedRow(id, ev);
		if (row[0]) {
			data = {fields:[],rows:[[]]};
			for (var i in details.columns) {
				data.fields.push(details.columns[i].field);
				data.rows[0].push(row.children(":nth(" + i + ")").html());
			}
		}
	}
}
// if we were provided with a field to drill into the row data
if (field && data && data.fields && data.rows && data.rows.length > 0) {
	// check multiSelect
	if (details.multiSelect) {
		// create complex data object if so
		data = {fields:[field],rows:[]};
	}
	// loop rows - non multi select will have only 1
	for (var i in data.rows) {
		var row = data.rows[i];
		var value = null;
		for (var j in data.fields) {
			if (data.fields[j] && data.fields[j].toLowerCase() == field.toLowerCase()) {
				value = data.rows[i][j];
				break;
			}
		}
		if (value != null) {
			if (details.muliSelect) {
				data.rows.push([]);
				data.rows[i].push(value);
			} else {
				data = value;
				break;
			}
		}
	}
}
return data;
			        ]]>      
	   	        </getPropertyFunction>
	   	        <setPropertyJavaScript>
	   	            <![CDATA[
gridData = getGridDataStoreData(id, details);
if (!gridData) gridData = {};
var grid = $("#" + id);
if (!grid.is("table")) grid = grid.find("table").last();
if (grid[0]) {
		var rowNumber = getGridSelectedRowNumber(id, ev);
		if (rowNumber != gridData.selectedRowNumber) {
			gridData.selectedRowNumber = rowNumber;
			saveGridDataStoreData(id, details, gridData);
		}
	}
data = makeDataObject(data, field);
if (gridData.selectedRowNumber && gridData.selectedRowNumber > 0) {
	// replace or remove selected row	
	if (data && data.fields && data.rows && data.rows.length > 0) {
		// get the gridData fields
		var gridDataFields = gridData.fields;
		// check there are some
		if (gridDataFields) {
			
			// set up a field map which will hold the location of the incoming fields in the grid fields
			var fieldMap = {};
			// loop the incoming fields
			for (var i in data.fields) {
				// get it's name
				var field = data.fields[i];
				// assume it wasn't found in the grid's list of fields	
				var foundField = false;							
				// loop the grid's fields
				for (var j in gridData.fields) {
					// if there's a match					
					if (field.toLowerCase() == gridData.fields[j].toLowerCase()) {
						// store it's position
						fieldMap[field] = j;
						foundField = true;
						break;
					}
				}
				// if the field wasn't found in the grid
				if (!foundField) {
					// add it to the grid's fields
					gridData.fields.push(field);
					// retain the position
					fieldMap[field] = gridData.fields.length - 1;
				}				
			}			
			// loop the incoming fields one more time
			for (var i in data.fields) {
				// add an entry at this position if we need one
				if (gridData.rows[gridData.selectedRowNumber - 1].length < data.fields.length) gridData.rows[gridData.selectedRowNumber - 1].push(null);
				// update the selected row field from the map
				gridData.rows[gridData.selectedRowNumber - 1][fieldMap[data.fields[i]]] = data.rows[0][i];
			}			
		} else {
			// take them from the incoming data object
			gridData.fields = data.fields;
			// put top row of what we were passed into selected row
			gridData.rows[gridData.selectedRowNumber - 1] = data.rows[0];
		}		
	} else {
		// remove the selected row 
		gridData.rows.splice(gridData.selectedRowNumber - 1, 1);
		// remove the validation entry if present
		if (gridData.rowValidation) gridData.rowValidation.splice(gridData.selectedRowNumber - 1, 1); 
		// remove the selection
		gridData.selectedRowNumber = null;
	}
	// if there is a datastore to save the data to
	if (details && details.dataStorageType) {
		// if the grid is visible in the page
		if ($("#" + id)[0]) {
	  		// update the grid with the gridData (which will save as well)
	  		setData_grid(ev, id, field, details, gridData, changeEvents);
	  	} else {
	  		// save the grid
	  		saveGridDataStoreData(id, details, gridData);
	  	}
	}
} else {
	// append if no selected row
	if (data) {
		// create a rows array if not present
		if (!gridData.rows) gridData.rows = [];
		// look for existing fields
		if (gridData.fields) {
		
			// set up a field map which will hold the location of the incoming fields in the grid fields
			var fieldMap = {};
			// loop the incoming fields
			for (var i in data.fields) {
				// get it's name
				var field = data.fields[i];
				// assume it wasn't found in the grid's list of fields	
				var foundField = false;							
				// loop the grid's fields
				for (var j in gridData.fields) {
					// if there's a match					
					if (field.toLowerCase() == gridData.fields[j].toLowerCase()) {
						// store it's position
						fieldMap[field] = j;
						foundField = true;
						break;
					}
				}
				// if the field wasn't found in the grid
				if (!foundField) {
					// add it to the grid's fields
					gridData.fields.push(field);
					// retain the position
					fieldMap[field] = gridData.fields.length - 1;
				}				
			}
			
			// make a row
			var row = [];
			// add the cells
			while (row.length < gridData.fields.length) row.push(null);
			// loop the data fields and use the map to get the correct position
			for (var i in data.fields) {
				// get the field
				var field = data.fields[i];
				// get the position
				var pos = fieldMap[field];
				// add it to the correct place in the row
				row[pos] = data.rows[0][i];
			}
			// add the row to the gridData
			gridData.rows.push(row);
		
		} else {
			
			// assume the incoming fields		
			gridData.fields = data.fields;
			// add the top row of what we were given
			gridData.rows.push(data.rows[0]);
		
		}
		
		// set the selected row number
		gridData.selectedRowNumber = gridData.rows.length;
		// save the grid
		saveGridDataStoreData(id, details, gridData);
		// if the grid is visible, refresh it
		if (grid[0]) setData_grid(ev, id, null, details, gridData, changeEvents);
	}	
}	   	            
	   	            ]]>
	   	        </setPropertyJavaScript>	        
	   	    </runtimeProperty>
	   	    
	   	    <runtimeProperty>
	   	        <type>selectedRowValidation</type>
	   	        <name>Selected row validation</name>
	   	        <getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData.rowValidation && gridData.selectedRowNumber) {
		return gridData.rowValidation[gridData.selectedRowNumber - 1];
	} 
} else {
	return getGridSelectedRowNumber(id, ev);
}
			        ]]>	  	   	            
	   	        </getPropertyFunction>	   	
	   	        <setPropertyJavaScript>
	   	            <![CDATA[
	   	            
var data = makeDataObject(data, field);
var selectedRowNumber = null;

// look for the grid on this page
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();
// if it's present
if (grid[0]) {
	// get the selected row number
	selectedRowNumber = getGridSelectedRowNumber(id, ev);
	// check the incoming data for a positive
	if (data[0][0]) {
		// remove validation class from row if true
		grid.find("tr.rowSelect").removeClass("validation");
	} else {
		// add validation class to row if false
		grid.find("tr.rowSelect").addClass("validation");
	}
}
	            	   	            
if (details && details.dataStorageType) {
	// get the grid data
	gridData = getGridDataStoreData(id, details);
	// make an object if there isn't one
	if (!gridData) gridData = {};
	// if we got a row number from the grid put it into the grid now
	if (selectedRowNumber) gridData.selectedRowNumber = selectedRowNumber;
	// if there are rows and one is selected
	if (gridData.rows && gridData.selectedRowNumber) {
		// add a rowValidation collection if there isn't one
		if (!gridData.rowValidation) gridData.rowValidation = [];
		// ensure the rowValidation collection is the same size as the row collection
		while (gridData.rows.length > gridData.rowValidation) gridData.rowValidation.push(true);
		// set the validation
		gridData.rowValidation[gridData.selectedRowNumber - 1] = data.rows[0][0];
		// save the grid
		saveGridDataStoreData(id, details, gridData);
	}
} 
	   	            ]]>
	   	        </setPropertyJavaScript>		   	                
	   	    </runtimeProperty>
	   	    
	   	    <runtimeProperty>
	   	        <type>selectedRowNumber</type>
	   	        <name>Selected row number</name>
	   	        <getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData && gridData.selectedRowNumber) {
		return gridData.selectedRowNumber;
	} else {
		return null;
	}
} else {
	return getGridSelectedRowNumber(id, ev);
}
			        ]]>	  	   	            
	   	        </getPropertyFunction>	   	
	   	        <setPropertyJavaScript>
	   	            <![CDATA[
gridData = getGridDataStoreData(id, details);
if (!gridData) gridData = {fields:[],rows:[]};
data = makeDataObject(data, field);
var selectedRowNumber = null;
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();
if (grid) grid.find("tr.rowSelect").removeClass("rowSelect");
if (data) {
	selectedRowNumber = data.rows[0][0];
	if (grid) grid.find("tr:eq(" + selectedRowNumber + ")").addClass("rowSelect");
}
gridData.selectedRowNumber = selectedRowNumber;	
saveGridDataStoreData(id, details, gridData);	            
	   	            ]]>
	   	        </setPropertyJavaScript>		   	                
	   	    </runtimeProperty>
	   	    
	   	    <runtimeProperty>
	   	        <type>rowCount</type>
	   	        <name>Row count</name>
	   	        <getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData && gridData.rows) {
		return gridData.rows.length;
	} else {
		return 0;
	}
} else {
	// get the grid
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// return number of rows
	return grid.find("tr").size() - 1;
}
			        ]]>	  	   	            
	   	        </getPropertyFunction>	   	        
	   	    </runtimeProperty>
	   	    
	   	</runtimeProperties>
	   	
	    <designLinkJQuery>
	        <![CDATA[
.filter( function() {
	var link = $(this);
	var id = link.attr("data-id");
	var details = window[id + "details"];
	if (details && details.dataStorageType) {
		return true;
	} else {
		link.hide();
	}
}).click( function(ev) {
	showDesignData($(this));
});	        	        
	        ]]>
	    </designLinkJQuery>
	   		    
	</control>
</controls>