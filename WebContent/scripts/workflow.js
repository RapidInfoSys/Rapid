/*

Copyright (C) 2017 - Gareth Edwards / Rapid Information Systems

gareth.edwards@rapid-is.co.uk


This file is part of the Rapid Application Platform

Rapid is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. The terms require you to include
the original copyright, and the license notice in all redistributions.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
in a file named "COPYING".  If not, see <http://www.gnu.org/licenses/>.

*/

/*

This is the core of the designer

Some terms:

Control - this refers to a control the user can add to a page, and is fairly high order, each control has a *.control.xml file in the controls directory that defines its behaviour

Object - this refers to the JQuery object made from the html

Geometry - the pixel space an object takes up 
 
*/

// details of all available action types
var _actionTypes = {};
// details of all available control types;
var _controlTypes = {};
// the option values with all available actions for adding to selects
var _actionOptions = "";
// details of all the available apps
var _apps = [];
// details of all the available application versions
var _versions = [];
// the version we are designing
var _version = {};
// the page of the app we are designing
var _page = {};
// a list of available pages
var _pages = [];
// a list of available actions
var _actions = [];
// a list of available style classes
var _styleClasses = [];

// the document window
var _window;
// the div that covers all of the components in design mode so they don't react to clicks
var _designCover;
// track whether the mouse is up or down
var _mouseDown = false;
// track mouseDown offsets
var _mouseDownXOffset = 0;
var _mouseDownYOffset = 0;
//  an object to hold the user-specified sizes of panels and dialogues
var _sizes = {};
// track whether we've moused down on the control panel resize
var _controlPanelSize = false;
// track whether we've moused down on the properties panel resize
var _propertiesPanelSize = false;
// track whether we've moused down on the dialogue resize
var _dialogueSize = false;
// the dialogue's id
var _dialogueSizeId;
// the resize type
var _dialogueSizeType;
// track whether we've added a control
var _addedControl = false;
// track whether we are currently moving a control
var _movingControl = false;
// we need to retain the control we have moved over
var _movedoverControl = null;
// we need to retain whether we are on the left or right so we insert before or after
var _movedoverDirection = "";
// we need to retain any controls we've moused over so we can fire mouse out
var _mousedOverControl = null;
// we need to retain whether the page order has been changed (no need to send and reprocess if not)
var _pageOrderChanged = false;
//we need to retain whether the page order has been reset too (this puts it back in alphabetical mode)
var _pageOrderReset = false;

// retain the currenty selected object
var _selectedControl = null;
// the div which we use a border around the selected object
var _selectionBorder;
// the div which we cover the selected object with whilst we are moving it around
var _selectionCover;
// the div which we place to show where an insert/move to the right would occur
var _selectionMoveLeft;
//the div which we place to show where an insert/move to the left would occur
var _selectionMoveRight;
// the div which we place to show where an insert would occur
var _selectionInsert;
// a div that we cover the parent object with to show it's full extent
var _selectionInsertCover;


// whether the left control panel is pinned
var _panelPinned = true;
// panel offset if pinned (includes padding and border)
var _panelPinnedOffset = 221;
// whether styles are hidden
var _stylesHidden = false;
// whether style classes are hidden
var _styleClassesHidden = false;

// scroll bar width
var _scrollBarWidth = 0;

// retain the copied control
var _copyControl;
// retain the copied action(s)
var _copyAction;
// undo stack
var _undo = [];
// redo stack
var _redo = [];
// whether there are unsaved changes
var _dirty;
// whether this page is locked for editing by another user
var _locked = false;

// the next control id
var _nextId = 1;
// the next page id
var _nextPageId = 1;

// a map of all former control and action id's and the new ones they get in the paste
var _pasteMap = {};
// an array of controls currently being generated by a paste
var _pasteControls = [];

// a global object for the different devices we are supporting, typically for mobiles
var _devices = [{name:"Desktop", width: 0, height: 0, ppi: 96, scale: 1 }];
// a global for the ppi of the device we've loaded the designer in
var _ppi = 96;
// a global for the selected device index
var _device = 0;
// the zoom factor at which we want to see the device screen
var _zoom = 1;
// the orientation we want to see the device screen
var _orientation = "P";
// the difference in resolution between screen and device * zoom
var _scale = 1;
// the scale * zoom
var _mouseScale;

// the div in which we are drawing the workflow
var _flowCanvas;
// the workflow we are currently editing
var _flow = {};
// all workflows
var _flows = [];
//track whether we are currently moving an action
var _movingAction = null;

//global jsPlumb instance
var _jsPlumb;
// reusable target (input) end point;
var _targetEndpoint;
// reusable source (output) end point;
var _sourceEndPoint;

// takes a snapshot of the current page and adds it to the undo stack
function addUndo(usePage, keepRedo) {	
	
	// must have a selected control or page
	if (_selectedControl || usePage) {	
		
		// set dirty
		_dirty = true;		
		
		// the undo control
		var undoControl = null;
		
		// stringify either selected or whole page
		if (usePage) {
			// snapshot the whole page
			undoControl = JSON.stringify(getDataObject(_page));
		} else {
			// retain childControls
			var childControls = _selectedControl.childControls;
			// remove them temporarily
			_selectedControl.childControls = null;
			// stringify the selected control
			undoControl = JSON.stringify(getDataObject(_selectedControl));
			// add back the child controls
			_selectedControl.childControls = childControls;
		}
		
		// if the control is different from the last item on the undo stack push it on
		if (_undo.length == 0 || (_undo.length > 0 && undoControl != _undo[_undo.length - 1])) _undo.push(undoControl);
		
		// remove an item from the bottom of the stack if it's too big
		if (_undo.length > 50) _undo.splice(0, 1);
		
		// enable undo button
		$("#undo").enable();
		
		// undo snapshots from the undo button create a redo snap shotshot if the snapshot request comes from elsewhere remove redo
		if (!keepRedo && _redo.length > 0) {
			// empty the redo stack
			_redo = [];
			// disable the redo button
			$("#redo").disable();
		} // keep redo
		
	} // control check
}

// used by both undo and redo to apply their snapshot
function applyUndoRedo(snapshot) {
	
	// check we were passed something to re-apply
	if (snapshot) {		
		
		// parse the snapshot
		var undoredoControl = JSON.parse(snapshot);
		
		// hide the selection border
		$("#selectionBorder").hide();
		// remove any dialogues or components
		$("#dialogues").children().remove();
		
		// find the control we are applying the undo to
		var applyControl = getControlById(undoredoControl.id);
		// make sure we got one
		if (applyControl) {
				
			// retain the selected control id
			var selectedControlId = null;
			// if we have a selected control
			if (_selectedControl) {
				// get it's the id
				selectedControlId = _selectedControl.id;
				// lose the current selected object
				_selectedControl = null;
			}						
			// lose the property control
			_propertiesControl = null;
			
			// retain reference to the object we are applying
			var applyObject = applyControl.object;			
			
			// if we're apply a page snapshot
			if (undoredoControl.type == "page") {
				
				// retain reference to page object
				var pageObject = _page.object;
								
				// if it's the whole page
				if (undoredoControl.childControls) {
					
					// retain a reference to the child controls
					var childControls = undoredoControl.childControls;
					
					// remove the children from the undoredo object
					delete undoredoControl.childControls;
					
					// remove all current page html
					pageObject.children().remove();
					
					// remove all non-visible controls
					$("img.nonVisibleControl").remove();
													
					// load the page object from the undo snapshot
					_page = new Control("page", null, undoredoControl, true, false, true);
					
					// put the page object back
					_page.object = pageObject;
					
					// we're re-doing the whole page so reset the next control id and control numbers 
					_nextId = 1;
					_controlNumbers = {};
					
					// loop the retained childControls and create
			    	for (var i = 0; i < childControls.length; i++) {
			    		// get an instance of the control properties (which is what we really need from the JSON)
			    		var childControl = childControls[i];
			    		// create and add
			    		_page.childControls.push(loadControl(childControl, _page, true, false, true));
			    	}
			    	
			    	// arrange any non-visible controls
			    	arrangeNonVisibleControls();
										
				} else {
					
					// retain a reference to the child controls
					var childControls = _page.childControls;
					
					// load the page object from the undo snapshot
					_page = new Control("page", null, undoredoControl, true, false, true);
					
					// put the page object back
					_page.object = pageObject;     	
									
					// put the child controls back
					_page.childControls = childControls;
					
				}
																															
			} else {
				
				// remove the object this snapshot is being applied to
				applyObject.remove();
				
				// loop the parent child controls
				for (var i in applyControl._parent.childControls) {
					// get a reference to the applychild
					var applyChildControl = applyControl._parent.childControls[i];
					// check if it's the one to replace
					if (applyChildControl.id == undoredoControl.id) {
						// copy in the child controls
						undoredoControl.childControls = applyChildControl.childControls;
						// update this child control
						applyControl._parent.childControls[i] = loadControl(undoredoControl, applyControl._parent, true, false, true);						
						// we're done
						break;
					}
				}
												
			}
									
			// if there was a control selected
			if (selectedControlId) {
				// re-select the initial control
				_selectedControl = getControlById(selectedControlId);
				// rebuild any properties
				selectControl(_selectedControl);
				// re apply any styles (this will call window resize)
				rebuildStyles();
			}
			
		} // apply control check
		
	} // undo snapshot check
	
}

// takes the most recent snapshot off the top of the undo stack and applies it
function doUndo() {
	// retrieve the last page from the top of the undo stack
	var undoSnapshot = _undo.pop();
	// if there was one
	if (undoSnapshot) {		
		// grab the page snapshot
		var pageSnapshot = JSON.stringify(getDataObject(_page));
		// only called in doUndo so less checking
		_redo.push(pageSnapshot);
		// enable undo button
		$("#redo").enable();
		// apply the undo
		applyUndoRedo(undoSnapshot);				
	}
	// if there's nothing more on the stack
	if (_undo.length == 0) {
		// disable undo button
		$("#undo").disable();
		// page can't be dirty either
		_dirty = false;
	}
}

// takes the most recent snapshot off the top of the redo stack and applies it
function doRedo() {
	// retrieve the last page from the top of the redo stack
	var redoSnapshot = _redo.pop();
	// if there was one
	if (redoSnapshot) {
		// add an undo snapshot for the whole page, just before we redo with the keep redo set to true
		addUndo(true, true);
		// apply the redo
		applyUndoRedo(redoSnapshot);		
	}
	// disable redo button if there's nothing more on the stack
	if (_redo.length == 0) $("#redo").disable();
}

// if the page is dirty prompt the user that they will lose unsaved changes
function checkDirty() {
	if (_dirty) {
		return confirm("You will lose your unsaved changes. Are you sure?");
	} else {
		return true;
	}
}

// this function shows the whole designer to the user, usually after the first page is loaded but possible earlier if there are no applications or pages
function showDesigner() {	
	// hide the loading message
	$("#loading").hide();
	// show the control panel and properties panel
	$("#designerTools").show();	
	// arrange any non-visible controls
	arrangeNonVisibleControls();
	// resize the elements on the page after a small delay
	windowResize("showDesigner");
	// show the first tip, if function is present
	if (window["showTip"]) showTip(0);
	// show the flow
	_flowCanvas.show();
	// repaint all of _jsPlumb;
	_jsPlumb.repaintEverything();
}

// this function load the apps into appsSelect
function loadFlows(selectedFlowId, forceLoad) {
	
	// hide the properties panel
	$("#propertiesPanel").hide();
	// remove all current page html
	$("#page").children().remove();
	// remove any dialogues or components
	$("#dialogues").children().remove();
	// remove any current apps
	$("#appSelect").children().remove();
	
	// do the ajax
	$.ajax({
    	url: "designer?action=getFlows",
    	type: "GET",
    	contentType: "application/json",
        dataType: "json",            
        data: null,            
        error: function(server, status, error) {
        	// check if there was permission to use rapid
        	if (server && server.status == 403) {
        		// reload the whole page (sends user to login)
        		loaction.reload();
        	} else {
        		// show the error
        		alert("Error loading work flows : " + error);
        	}
        },
        success: function(flows) {        	
        	// if a flow is not selected try the url
        	if (!selectedFlowId) var urlFlowId = $.getUrlVar("f");
        	// build the select options for each app
        	var options = "";
        	// loop the apps we received
        	for (var i in flows) {        		
        		// get a reference to the app
        		var flow = flows[i];
        		// add an option for this page (if not the rapid app itself)
        		options += "<option value='" + flow.id + "' " + (selectedFlowId || urlFlowId == flow.id ? "selected='true'" : "") + ">" + flow.name + "</option>";        	
        	}
        	// get a reference to apps dropdown
        	var flowsDropDown = $("#flowSelect");
        	// put the options into the dropdown and enable
        	flowsDropDown.html(options).enable();
        	// retain all the apps data
        	_flows = flows;        	       	
        	// if we got some apps
        	if (flows.length > 0) {
	        	// load the app and its pages in the drop down if we weren't handed one
	        	if (!selectedFlowId || forceLoad) {
	        		// load the versions for the app, or top app
	        		loadVersions();
	        	} else {
	        		// show the designer
	        		showDesigner();
	        	}
        	} else {
        		// disable a bunch of stuff as there there are no apps
        		$("#appDelete").attr("disabled","disabled");
        		$("#appEdit").attr("disabled","disabled");
        		$("#pageNew").attr("disabled","disabled");
        		$("#pageEdit").attr("disabled","disabled");
        		$("#pageSave").attr("disabled","disabled");
        		$("#pageView").attr("disabled","disabled");        		
        		$("#pageViewNewTab").attr("disabled","disabled");        		
        		// show the designer
        		showDesigner();
        	}        	
        }
	});
}

// this function locks the ui whilst either versions, pages, or a page are loading
function loadLock(level) {
		
	// hide the properties panel
	$("#propertiesPanel").hide();
	
	// disable all page buttons (except rapid admin)
	$("button:not(#appAdmin):not(#appAdminNewTab)").disable();
	
	// disable all page drop downs
	$("select").disable();
	
	// disable page back/forwards
	$("img.pageNav").addClass("pageNavDisabled");
					
	// loading versions - loadVersions (changed app)
	if (level == 1) {		
		// remove any current versions
		$("#versionSelect").children().remove();
		// hide any actions
		$("#actionActions").hide();
	}
	
	// reloading the pages is used to get their new order so is a little different as the page itself is not reloaded
	if (level == 2) {
		// clear down property dialogues for good measure
		hideDialogues();
		// show loading in div if not pages reloading for updated order
		_flowCanvas.html("<div><div class='pageLoading'><p><img src='images/wait_220x19.gif' /></p><p style='margin-left:20px;'>loading...</p></div></div>");		
		// set the next id back
		_nextId = 1;
		// empty undo stack
		_undo = [];	
		// empty redo stack
		_redo = [];
		// grab a reference to the ul where the canUserAdd controls will be added
		var designActions = $("#actionsList");
		// hide the controls panel
		designActions.hide();
		// empty the designControls panel
		designActions.html("<ul class='design-controls'></ul>");	
		// empty the action options global
		_actionOptions = "";
	}
		
}

// this function loads the versions into versionSelect
function loadVersions(selectedVersion, forceLoad) {
		
	// lock the ui
	loadLock(1);
	
	// do the ajax
	$.ajax({
    	url: "designer?a=" + $("#appSelect").val() + "&action=getFlowVersions",
    	type: "GET",
    	contentType: "application/json",
        dataType: "json",            
        data: null,            
        error: function(server, status, error) {
        	// check if there was permission to use rapid
        	if (server && server.status == 403) {
        		// reload the whole page (sends user to login)
        		loaction.reload();
        	} else {
        		// show the error
        		alert("Error loading versions : " + error);
        	}
        },
        success: function(versions) {        
        	
        	// get a reference to apps dropdown
        	var versionsDropDown = $("#versionSelect");
        	// check there are some versions
        	if (versions && versions.length > 0) {        		
        		// if a version is not specified for selection
            	if (!selectedVersion) {
            		// try the url
            		var urlVersion = $.getUrlVar("v");
            		// if we got something
            		if (urlVersion) {
            			// retain url version as selected
            			selectedVersion = urlVersion;
            		} else {
            			// set selected to last version in collection
            			selectedVersion = versions[versions.length - 1].version;
            		}
            		// force a reload
            		forceLoad = true;
            	}
            	// build the select options for each app
            	var options = "";
            	// loop the apps we received
            	for (var i in versions) {        		
            		// get a reference to the app
            		var version = versions[i];
            		// derived the status text (these must match final ints at the top of Application.java)
            		var status = "";
            		// live = 1
            		if (version.status == 1) status = " - (Live)";
            		// add an option for this page, setting selected
            		options += "<option value='" + version.version + "' " + (selectedVersion == version.version ? "selected='true'" : "") + ">" + version.version + status + "</option>";        	
            	}            	
            	// put the options into the dropdown and enable
            	versionsDropDown.html(options).enable();            	
            	// retain all the versions data
            	_versions = versions;        	
            	// set the selected _version
            	_version = _versions[versionsDropDown[0].selectedIndex];
            	// load the flow in the drop down if we weren't handed one
            	if (!selectedVersion || forceLoad) {
            		loadVersion();
            	} else {
            		// show the designer
            		showDesigner();
            	}
        		
        	} // versions check	
        }
	});
}

// this function loads the version pages into pagesSelect
function loadVersion(forceLoad) {
	
	// lock the ui
	loadLock(2);
			
	// check we have some versions
	if (_versions) {
		// get the selected version Id
		_versionId = $("#versionSelect").val();
		// loop all the apps
    	for (var i in _versions) {    		
    		// if this app matches what's in the dropdown
    		if (_versions[i].version == _versionId) {
    			// set the global to this one
    			_version = _versions[i];
    			// we're done
        		break;
    		}    		
    	}
	}
			
	// check there is a version
	if (_version) {		
							
		// grab a reference to the ul where the canUserAdd controls will be added
		var designActions = $("#actionsList");
		
		// loop the actions
    	for (var j in _version.actions) {	    	    		
    		
    		// get a reference to a single action
    		var a = _actionTypes[_version.actions[j].type];
    		
    		// if the control can be added by the user
    		if (a.visible || a.visible === undefined) {
    			
    			// make the list entry
    			var li = "<li id='a_" + a.type + "' class='design-action' data-action='" + a.type + "'>" + (a.image ? "<img src='" + a.image + "' draggable='false' />" : "<img src='images/tools_24x24.png'/>") + "</li>";
    			
    			// check for a category
    			if (a.category) {    				
    				// check for a sub list
    				var ul = designActions.parent().find("ul[data-for='" + a.category + "']");
    				// if we got one
    				if (ul[0]) {
    					// add entry to list
    					ul.append(li);
    				} else {
    					// add list and entry
    					designActions.append("<h3>" + a.category + "</h3><ul class='design-actions' data-for='" + a.category + "'>" + li + "</ul>");
    					// find the list
    					ul = designActions.parent().find("ul[data-for='" + a.category + "']");
    				}
    				// find the list entry
    				li = ul.children().last();
    			} else {
	    			// add button to first ul
    				designActions.find("ul").first().append(li);
	    			// now fetch it into the li variable
	    			li = designActions.children().last();
    			}
    			
    			// add it's name as a help hint
    			addHelp("a_" + a.type, false, false, a.name);
    			    			    			
    		} // userCanAdd
    		
    	} // app control loop 

    	// when the mouse moves down on any action button
    	designActions.find("li").on("mousedown touchstart", function(ev) {		
			
			// clear down property dialogues for good measure
			hideDialogues();
			
			// add an undo for the whole flow
			addUndo(true);
			
			// stop text selection as we are moving the new object
			$("body").css({
				"-webkit-touch-callout":"none",
				"-webkit-user-select":"none",
				"-khtml-user-select":"none",
				"-moz-user-select":"-moz-none",
				"-ms-user-select":"none",
				"user-select":"none"
			});	
						
			// hide the panel if not pinned
			if (!_panelPinned) hideControlPanel();
			
			// hide the properties
			hidePropertiesPanel();
									
			// define the id for this action
			var id = "A" + _nextId + "_";
			
			// increment the next id
			_nextId ++;
			
			// add a flow action
			addFlowAction(id, ev.pageX - 15 - _panelPinnedOffset, ev.pageY - 15, $(ev.target).attr("data-action"));
			
			// record we are  moving an action 
			_movingAction = id;
			
			// get the element
			var e = $("#" + id);
			// set it's z-index above the li's
			e.css("z-index",20000);
			
			// fire the down  listener on the new action div
			_jsPlumb.getElement(e)._katavorioDrag.downListener(ev);
			
			// we only need the hit on the li
			ev.stopPropagation();
									
		}).find("img").on("dragstart",function() { return false; }); // mouse down, and stop drag for image
    			    	
    	// resize the controls list (for the right height and padding)
    	sizeActionsList();
    	
    	// empty the flowCanvas
    	_flowCanvas.html("");
    	
    	addFlowAction("A11_", 100, 100, "database");
        addFlowAction("A12_", 250, 250, "email");
        addFlowAction("A13_", 100, 500, "logic");
        
        addFlowOutput("A11_successActions", "A12_I");

	} // version check
	
	// show the designer
	showDesigner();
	
	// show the actions
	designActions.show();
	$("#actionActions").show();
	
}

// this function removes properties that create circular references from the control tree when saving
function getDataObject(object) {
	// make a new empty object
	var o = {};
	// loop the properties
	for (var i in object) {
		// ignore "static" properties, or those that create circular references
		if (i.indexOf("_") != 0 && i != "XMLVersion" && i != "object") {
			// grab a property
			var p = object[i];
			// if a blank space, or not a null
			if (p === "" || p != null) {
				// child controls and actions need cleaning up recursively 
				if (p.type && (_actionTypes[p.type] || _controlTypes[p.type])) {
					// get an object
					o[i] = getDataObject(p);
				} else if ($.isArray(p) && p.length > 0 && p[0] && p[0].type && (_actionTypes[p[0].type] || _controlTypes[p[0].type] || i == "events" )) {
					// make an array
					o[i] = [];
					// loop to clean up childControls
					for (var j in p) o[i].push(getDataObject(p[j]));								
				} else {
					// simple copy
					o[i] = p;
				}
			}
		}
	}
	// return our safe object
	return o;	
}

function cleanControlForPaste(control) {
	// create an empty clean control object
	var cleanControl = {};	
	// loop the properties, ignoring certain ones
	for (var i in control) {
		if (i.indexOf("_") != 0 && i != "object" && i != "childControls") {
			cleanControl[i] = control[i];
		}
	}
	// add a child control collection
	cleanControl.childControls = [];
	// loop the child controls
	for (var i in control.childControls) {
		// add a clean child control
		cleanControl.childControls.push(cleanControlForPaste(control.childControls[i]));
	}
	// return the clean control
	return cleanControl;
}

// this function will paste an existing control into a specified parent - if no parent is specified we assume we are pasting a whole page
function doPaste(control, _parent) {
		
	// remove any dialogues or components
	$("#dialogues").children().remove();
	
	// reset the paste map
	_pasteMap = {};
	// reset the paste controls
	_pasteControls = [];
	
	// it's a little different for the page (we can idenitfy it as it doesn't have a parent)
	if (_parent) {
		
		// create the new control
		var newControl = loadControl(control, _parent, true, true);
		
		// retain the next id at this point
		var nextId = _nextId;
		
		// retain the control numbers at this point
		var controlNumbers = JSON.stringify(_controlNumbers);
		
		// remove the current object if not the body
		if (!newControl.object.is("body")) newControl._remove();
		
		// remove any items that were placed in dialogues
		$("#dialogues").children().remove();
		
		// clean the control for stringifying
		var cleanControl = cleanControlForPaste(newControl);
		
		// stringify newControl
		var newControlString = JSON.stringify(cleanControl);
		
		// loop all entries in the paste map
		for (var i in _pasteMap) {
			// get the old id
			var oldId = _pasteMap[i];
			// get the new id
			var newId = i;
			// check the end of the old id for _ (very old controls in the Rapid app may still not end in _ which is a problem for the search and replace and we need to avoid, say C629 being replaced with C62)
			if (oldId[oldId.length - 1] == "_") {
				// this is fine so update references as is
				newControlString = newControlString.replaceAll(oldId, newId);
			} else {
				// update references with quotes to avoid collisions in old ids
				newControlString = newControlString.replaceAll(oldId + '"', newId + '"');
				// update references with spaces to avoid collisions in old ids
				newControlString = newControlString.replaceAll(oldId + " ", newId + " ");				
			}
		}
		
		// turn the replaced string back into an object
		var mappedControl = JSON.parse(newControlString);
		
		// reload the control with all the new references
		newControl = loadControl(mappedControl, _parent, true, true, false, true);
		
		// apply any styling in the new control
		applyStyleForPaste(newControl);
		
		// restore the next id
		_nextId = nextId;
		
		// restore the control numbers
		_controlNumbers = JSON.parse(controlNumbers);
		
		// fire window resize in case scroll bars need adjusting, etc. (this will re-select)
		windowResize("paste");
								
		// return the updated control
		return newControl;
				
	} else {
			
		// remove all children
		_page.object.children().remove();																				
		// reset the next id at this point
		_nextId = 1;
		// reset the control numbers at this point
		_controlNumbers = {};
		// retain the page id
		var id = _page.id;
		// retain the page name
		var name = _page.name;
		// retain the page name
		var title = _page.title;
		// retain the page name
		var description = _page.description;
				
		// stringify control
		var controlString = JSON.stringify(control);
		
		// update all references of the page id to this page id
		controlString = controlString.replaceAll(control.id + "_",id + "_");
		
		// turned the replaced string back into an object
		var mappedControl = JSON.parse(controlString);
		
		// add back object from the current page
		mappedControl.object = _page.object;
		
		// reload the page control using the undo functionality (this preserves the control ids)
		_page = loadControl(mappedControl, null, true, false, true, true);

		// restore the id
		_page.id = id;
		// restore the name
		_page.name = name;
		// restore the title
		_page.title = title;
		// restore the description
		_page.description = description;
		// set the page object to the iframe body
		_page.object = $(_pageIframe[0].contentWindow.document.body);
		
		// apply any styling in the new control
		applyStyleForPaste(_page);
				
		// fire window resize in case scroll bars need adjusting, etc.
		windowResize("paste");
		
		// return the page
		return _page;		
		
	}
			
}

// a function for animating the hide/show headers
function toggleHeader(ev) {
	var header = $(this);
	var contents = header.next();
	contents.slideToggle( 500, function() {
		if (contents.is(":visible")) {
			header.children("img.headerToggle").attr("src","images/triangleUpWhite_8x8.png");						
		} else {
			header.children("img.headerToggle").attr("src","images/triangleDownWhite_8x8.png");
		}
		switch (header.attr("id")) {
		case "stylesHeader" :
			_stylesHidden = !contents.is(":visible");
			break;
		case "styleClasssesHeader":
			_styleClassesHidden = !contents.is(":visible");
			break;
		}
		windowResize("toggleHeader");
	});		
	return false;	
}

// JQuery is ready! 
$(document).ready( function() {
	
	//console.log("Jquery is ready!");
	
	// derive the scroll bar width first - http://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes
	var inner = document.createElement('p');
	inner.style.width = "100%";
	inner.style.height = "200px";

	var outer = document.createElement('div');
	outer.style.position = "absolute";
	outer.style.top = "0px";
	outer.style.left = "0px";
	outer.style.visibility = "hidden";
	outer.style.width = "200px";
	outer.style.height = "150px";
	outer.style.overflow = "hidden";
	outer.appendChild (inner);

	document.body.appendChild (outer);
	var w1 = inner.offsetWidth;
	outer.style.overflow = 'scroll';
	var w2 = inner.offsetWidth;
	if (w1 == w2) w2 = outer.clientWidth;

	document.body.removeChild(outer);

	_scrollBarWidth = (w1 - w2);
	
	// the control panel on the left
	var controlPanelInner = $("#controlPanelInner");
	// the properties panel on the right
	var propertiesPanel = $("#propertiesPanel");
	
	// the window we are working in
	_window = $(window);	
	
	// the workflow div
	_flowCanvas = $("#flowCanvas");
	
	// prevent any dragging and ghost images 
	_window.on("dragstart", function(ev) { ev.preventDefault(); });
	
	_window.scroll( function() {
		// adjust the control panel left / right
		controlPanelInner.css("left",-$(this).scrollLeft() + 10);
		// adjust the properties panel left/right
		propertiesPanel.css("right",-$(this).scrollLeft());
	});
	
	// the div that covers all of the components in design mode so they don't react to clicks
	_designCover = $("#designCover");
			
	// check if we have local storage
	if (typeof(localStorage) !== "undefined") {
		// if we have a saved control panel width
		if (localStorage["_sizes"]) {
			// retain it locally
			_sizes = JSON.parse(localStorage["_sizes"]);
			// set controlPanelWidth if present
			if (_sizes["controlPanelWidth"]) sizeActionsList(_sizes["controlPanelWidth"]);
			// set propertiesPanelWidth if present
			if (_sizes["propertiesPanelWidth"]) $("#propertiesPanel").width(_sizes["propertiesPanelWidth"]);
			// if we have a local storage item for the guidlines
			if (localStorage.getItem("_guidelines")) showGuidelines = JSON.parse(localStorage.getItem("_guidelines"));			
		}
	}
		
	// derived the panel pinned offset value (add on the padding and border)
	_panelPinnedOffset = $("#controlPanel").width() + 21;
	
	//  if we move away from this page
	_window.on('beforeunload', function(){
		// save the _sizes object if local storage
		if (typeof(localStorage) !== "undefined") localStorage["_sizes"] = JSON.stringify(_sizes);
		// check for unsaved page changes
		if (_dirty) return 'You have unsaved changes.';
	});
	
	// attach a call to the window resize function to the window resize event listener
	_window.resize("windowResize", windowResize);		
	// reposition the selection if there's a scroll
	_window.scroll( function(ev) {
		positionAndSizeBorder(_selectedControl);
	});
	
	// scroll the iFrame top if it's outer scroll bar is used
	$("#scrollV").scroll( function(ev) {
		_pageIframeWindow.scrollTop($(ev.target).scrollTop());
		positionBorder(_selectedControl);		
	});
	
	// scroll the iFrame left if it's outer scroll bar is used
	$("#scrollH").scroll( function(ev) {
		_pageIframeWindow.scrollLeft($(ev.target).scrollLeft());
		positionBorder(_selectedControl);
	});
				
	// load the action classes
	$.ajax({
    	url: "designer?action=getSystemData",
    	type: "GET",
    	contentType: "application/json",
        dataType: "json",       
        data: null,            
        error: function(server, status, error) {
        	// just show an error        	
        	alert("Error loading system data : " + error); 
        },
        success: function(systemData) {        
        	
        	// check we got some
        	if (systemData) {
        		
        		// get the actions
        		var actions = systemData.actions;
        		
        		// loop the actions we got back
    	    	for (var i in actions) {
    	    		// get a reference to a single action
    	    		var a = actions[i];
    	    		// create a new action class object/function (this is a closure)
    	    		var f = new ActionClass(a);        		        		     			
    				// retain the action class object/function globally
    	    		_actionTypes[a.type] = f; 	    		
    	    	} // action loop
        		
        		// get the controls
        		var controls = systemData.controls;
        		
        		// loop the controls we got back
    	    	for (var i in controls) {
    	    		// get a reference to a single control
    	    		var c = controls[i];
    	    		// create a new control ControlClass object/function (this is a closure)
    	    		var f = new ControlClass(c);        		        		     			
    				// retain the control controlClass function function globally
    				_controlTypes[c.type] = f; 	
    	    	}
        		
        		// if we got devices store them globally
        		if (systemData.devices) _devices = systemData.devices;
        		        		
        		// check if we have local storage
        		if (typeof(localStorage) !== "undefined") {
        			// retrieve device index from local storage
        			var device = localStorage.getItem("_device");
        			// if there was one and there's a slot for it in our devices
        			if (device && device * 1 < _devices.length) _device = device*1;
        			// retrieve the orientation
        			var orientation = localStorage.getItem("_orientation");
        			// update global if we got one
        			if (orientation) _orientation = orientation;
        			// retrieve the zoom
        			var zoom = localStorage.getItem("_zoom");
        			// update global if we got one
        			if (zoom) _zoom = zoom*1;
        			// calculate the scale
        			_scale = _ppi / _devices[_device].PPI * _devices[_device].scale * _zoom;
        		}
        		
        		// now load the workflows
    	    	loadFlows();
        		
        	} // got system data
	    	        		    		    		    	
        } // load actions success function
        
    }); // load actions ajax
		
	// control panel resize
	$("#controlPanelSize").on("mousedown", function(ev) {
		// retain that we are resizing the control panel
		_controlPanelSize = true;
		// retain the mouse offset
		_mouseDownXOffset = ev.pageX - parseInt($("#controlPanel").css("width"));
	});
	
	// property panel resize
	$("#propertiesPanelSize").on("mousedown", function(ev) {
		// retain that we are resizing the control panel
		_propertiesPanelSize = true;
		// retain the mouse offset
		_mouseDownXOffset = ev.pageX - $("#propertiesPanel").offset().left;
	});
		
	// panel pin
	$("#controlPanelPin").click( function(ev) {
		// check pinned
		if (_panelPinned) {
			_panelPinned = false;			
			$("#controlPanelPin").html("<img src='images/triangleDownWhite_8x8.png' title='pin panel'>");
			// set the panel pin offset
			_panelPinnedOffset = 0;			
			// arrange the non visible controls due to the shift in the panel
			arrangeNonVisibleControls();	
			// hide control panel
			hideControlPanel();
		} else {
			_panelPinned = true;
			_panelPinnedOffset = $("#controlPanel").width() + 21; // add the padding and border
			$("#controlPanelPin").html("<img src='images/triangleLeftWhite_8x8.png' title='unpin panel'>");
			// resize the window
			windowResize("unpin");
			// arrange the non visible controls due to the shift in the panel
			arrangeNonVisibleControls();
		}
	});
	
	// panel slide out
	$("#controlPanelShow").mouseenter( function(ev){
		// show the panel if we're not moving a control
		if (!_movingControl) {
			// show the panel
			$("#controlPanel").stop(true, true).show("slide", {direction: "left"}, 200, function() {
				// show the inner when the animation has finished
				$("#controlPanelInner").show();
			});			
		}
	});
	
	// panel slide in
	$("#controlPanel").mouseleave( function(ev){		
		// if the panel isn't pinned and this not the selected control
		if (!_panelPinned && !$(ev.target).is("select")) {
			// slide the control panel back in
			hideControlPanel(true);	
		}
	});

	// administration
	$("#appAdmin").click( function(ev) {
		if (_version && _version.id) {
			window.location = "~?a=rapid&appId=" + _version.id + "&version=" + _version.version;
		} else {
			window.location = "~?a=rapid";
		}		 
	});
	
	// administration, new tab
	$("#appAdminNewTab").click( function(ev) {
		if (_version && _version.id) {
			window.open("~?a=rapid&appId=" + _version.id + "&version=" + _version.version,"_blank");
		} else {
			window.open("~?a=rapid","blank");
		}		 
	});
	
	// load app
	$("#appSelect").change( function() {
    	// load the selected app and its pages in the drop down 
    	if (checkDirty()) {
    		// update the url, removing the version so the last one will be loaded for us
        	if (window.history && window.history.replaceState) window.history.replaceState("page", _page.title, "workflow.jsp?a=" + _version.id);   
        	// load the versions
    		loadVersions();
    	} else {
    		// revert the drop down on cancel
    		$("#appSelect").val(_version.id);
    	}
	});
	
	// load version
	$("#versionSelect").change( function() {
    	// load the selected app and its pages in the drop down 
    	if (checkDirty()) {
    		// update the url, removing the version so the right one is loaded to it's own start page
        	if (window.history && window.history.replaceState) window.history.replaceState("page", _page.title, "workflow.jsp?a=" + _version.id);   
        	// load the version
    		loadVersion();
    	} else {
    		// revert the drop down on cancel
    		$("#versionSelect").val(_version.version);
    	}
	});
			
	// load workflow
	$("#pageSelect").change( function() {
		// load the selected page
		if (checkDirty()) {
			loadPage();
		} else {
			// revert the drop down on cancel
			$("#pageSelect").val(_page.id);
		}
	});
	
	// edit workflow
	$("#pageEdit").click( function(ev) {
		// hide any selection border
		_selectionBorder.hide();
		// set the selected control to the page
		selectControl(_page);		
	});
	
	// new workflow
	$("#pageNew").click( function(ev) {
		if (checkDirty()) showDialogue('~?action=page&a=rapid&p=P3'); 
	});
	
	// save page
	$("#pageSave").click( function() {
		
		// get a reference to the button
		var button = $(this);
		
		// only if not disabled
		if (!button.attr("disabled")) {
			
			// disable the button
			button.disable();
			
			// hide all property dialogues
			hideDialogues();
			
			// show the saving page dialogue with 
			showDialogue('~?action=page&a=rapid&p=P11', function() {
				
				// show message
				$("#rapid_P11_C7_").html("Saving page...");
				
				// send the data to the backend
				$.ajax({
			    	url: "designer?action=savePage&a=" + _version.id + "&v=" + _version.version,
			    	type: "POST",
			    	contentType: "application/json",
			        dataType: "json",            
			        data: getSavePageData(),            
			        error: function(server, status, error) { 
			        	// show error
			        	$("#rapid_P11_C7_").html(error);
			        	// enable close button
			        	$("#rapid_P11_C10_").enable().focus();
			        },
			        success: function(controls) {
			        	// show message
			        	$("#rapid_P11_C7_").html("Page saved!");			        	
			        	// set dirty to false
			        	_dirty = false;
			        	// reload the pages as the order may have changed, but keep the current one selected
			        	loadPages(_page.id, false);		        	
			        	// enable close button
			        	$("#rapid_P11_C10_").enable().focus();			        	
			        }
				});
				
			});
			
		}
		
	});
	
	// undo
	$("#undo").click( function(ev) {
		doUndo(); 
		buildPageMap();
	});
	
	// redo
	$("#redo").click( function(ev) {
		doRedo();
		buildPageMap();
	});
	
	// properties panel pin (for now just hide)
	$("#propertiesPanelPin").click( function(ev) {
		// select a null control (this does a lot of cleanup)
		selectControl(null);				
		// hide the select border
		_selectionBorder.hide();
	});						
	
	// delete action
	$("#deleteAction").click( function(ev) {
	
	});
	
	// copy
	$("#copy").click( function(ev) {

	});
	
	// paste
	$("#paste").click( function(ev) {
	
	});		
	
	// properties header toggle
	$("#propertiesHeader").click( toggleHeader );
	
	// keyboard short-cuts
	$(window).on('keydown', function(ev) {
		var t = $(ev.target);
		if (event.ctrlKey || event.metaKey) {
	        switch (String.fromCharCode(ev.which).toLowerCase()) {
	        case 's':
	            ev.preventDefault();
	            $("#pageSave").click();
	            break;
	        case 'z':
	            ev.preventDefault();
	            if (ev.shiftKey) {
	            	$("#redo").click();
	            } else {
	            	$("#undo").click();
	            }
	            break;
	        case 'c':
	        	if (t.is("body") && (!window.getSelection || !window.getSelection().toString())) {
		            ev.preventDefault();
		            if (_selectedControl) $("#copy").click();
	        	}
	            break;
	        case 'v':
	        	if (t.is("body")) {
		            ev.preventDefault();
		            if (_copyControl) $("#paste").click();
	        	}
	            break;
	        }
	    }
	});
							
});

//called whenever a control is added or deleted in case one was a non-visible control and needs rearranging
function arrangeNonVisibleControls() {	
	// check there is a page and a page object
	if (_page && _page.object && _page.childControls) {
				
		// start at first x position
		var x = _panelPinnedOffset + 10;
		
		// loop the page child controls
		for (var i in _page.childControls) {
			
			// get the child control
			var childControl = _page.childControls[i];
			// get the class
			var childControlClass = _controlTypes[childControl.type];
			
			// if it is nonVisible
			if (childControlClass.getHtmlFunction.indexOf("nonVisibleControl") > 0) {
				
				// get the object
				var	o = childControl.object;
				
				// check if in the page
				if (o.parent().is(_page.object)) {
					// move into the designer and update the reference
					o = $("body").append(o).children().last();
					// add back to the control
					childControl.object = o;
				} 
				
				// ensure the object is visible
				o.show();
				// ensure the object is in the right place
				o.css({"position":"fixed","bottom":"10px","left":x});
				// get the width
				var w = Math.max(o.outerWidth(),25);
				// add to the growing x value
				x += (5 + w);
				
			}
		}		
	}	
}

//this gets the working height from the max of the control panel, iframe, properties panel, and screen 
function getHeight() {
		
	// get the window height
	var height = _window.height();
				
	// get the control panel
	var controlPanel = $("#controlPanelInner");
		
	// get the properties panel
	var propertiesPanel = $("#propertiesPanelInner");
			
	// get its current height
	var controlPanelHeight = controlPanel.outerHeight(true) + 10;
		
	// get its current height
	var propertiesPanelHeight = propertiesPanel.outerHeight(true) + 10;

	// increase height to the tallest of the window, the panels, or the iFrame
	height = Math.max(height, controlPanelHeight, propertiesPanelHeight);
			
	return height;
	
}

// this makes sure the properties panel is visible and tall enough for all properties
function showPropertiesPanel() {
	
	// set all controls to readonly if the page is locked
	if (_locked) {		
		// get the properties panel to include actions and styles
		var propertiesPanel = $("#propertiesPanel");
		// get the dialogues
		var propertiesDialogues = $("#propertiesDialogues");
		// disable inputs
		propertiesPanel.find("input").attr("disabled","disabled");
		propertiesDialogues.find("input").attr("disabled","disabled");
		// disable drop downs
		propertiesPanel.find("select").attr("disabled","disabled");
		propertiesDialogues.find("select").attr("disabled","disabled");
		// readonly textareas
		propertiesPanel.find("textarea").attr("readonly","readonly");
		propertiesDialogues.find("textarea").attr("readonly","readonly");
		// disable deletes
		propertiesPanel.find("img").off("click");
		propertiesDialogues.find("img").off("click");	
		// disable order moves
		propertiesPanel.find("img").off("mousedown");
		propertiesDialogues.find("img").off("mousedown");
	}
		
	// size the panel (less padding) and show - note the .stop(true, true) which clears any current animation queue and sets the final settings immediately 
	$("#propertiesPanel").css("height",getHeight() - 20).stop(true, true).show("slide", {direction: "right"}, 200, function(){
		// show the inner 
		$("#propertiesPanelInner").show()
	});
					
}

function hideControlPanel(resetOffset) {
	// slide the control panel
	$("#controlPanel").stop(true, true).hide("slide", {direction: "left"}, 200, function() {
		// hide the inner
		$("#controlPanelInner").hide();
		// set the panel pin offset
		if (resetOffset) _panelPinnedOffset = 0;
		// resize the window
		windowResize("pin");		
	});
	// hide the inner
	$("#controlPanelInner").hide();
}

function hidePropertiesPanel() {	
	// hide the inner
	$("#propertiesPanelInner").hide();
	// slide in the panel - note the .stop(true, true) which clears any current animation queue and sets the final settings immediately 
	$("#propertiesPanel").stop(true, true).hide("slide", {direction: "right"}, 200);
}

// size the actions list (used when resizing control panel and starting / loading versions)
function sizeActionsList(width) {
	// check if a width was provided
	if (width) {
		// set the new width 
		$("#controlPanel").css("width", width);
	} else {
		// read in the current width
		width = parseInt($("#controlPanel").css("width"));
	}
	// size the inner
	$("#controlPanelInner").css("width",width);
	// get the actions list
	var actionsList = $("#actionsList");
	// get the first action
	var action = actionsList.find("li").first();
	// get the width of the first action
	var actionWidth = action.outerWidth(true);
	// get the actions wide
	var actionsWide = Math.floor(width / actionWidth);
	// assume no actions
	var actionsCount = 0;
	// loop the ul's to get the greatest number of controls
	actionsList.find("ul").each( function() {
		var actions = $(this).children().size();
		if (actions > actionsCount) actionsCount = actions;
	});
	// if the actions are wrapping
	if (actionsCount > actionsWide) {
		// set the fixed height and margin (to allow animation and center controls)
		actionsList.css({
			"padding-left" : (width - actionsWide * actionWidth) / 2
		});
	} else {
		//
		actionsList.css({
			"padding-left" : 0
		});
	}
}

//if the mouse moves anywhere
$(document).on("mousemove touchmove", function(ev) {
	
	if (_controlPanelSize) {
	
		// get the control panel
		var panel = $("#controlPanel");
		// get the min-width
		var minWidth = parseInt(panel.css("min-width"));
		// calculate the new width less offset and padding
		var width = ev.pageX - _mouseDownXOffset;
		// if width is between max and min
		if (width >= minWidth && width < _window.width() - _scrollBarWidth - 21) {
			// size the actions list
			sizeActionsList(width);
			// retain this width in the sizes object
			_sizes["controlPanelWidth"] = width;
		}
				
	} else if (_propertiesPanelSize) {
	
		// get the control panel
		var panel = $("#propertiesPanel");
		// get the min-width
		var minWidth = parseInt(panel.css("min-width"));
		// calculate the new width less offset and padding
		var width = _window.width() - ev.pageX - 21 + _mouseDownXOffset;
		// if width is between max and min
		if (width >= minWidth && width <  _window.width() - _scrollBarWidth - 21) {
			// size the properties panel
			panel.css("width", width);
			// size the inner panel
			$("#propertiesPanelInner").width(width);
			// retain this width in the sizes object
			_sizes["propertiesPanelWidth"] = width;
		}
				
	} else if (_dialogueSize) {
		
		// get the dialogue
		var dialogue = $("#" + _dialogueSizeId);
		// get the min-width
		var minWidth = parseInt(dialogue.css("min-width"));
		// calculate the new width less offset and padding
		var width = _window.width() - ev.pageX - 32 + _mouseDownXOffset;
		// if width is greater than min
		if (width >= minWidth) {
			// size the properties panel
			dialogue.css(	"width", width);
			// retain this width in the sizes object
			_sizes[_version.id + _version.version + _dialogueSizeId + "width"] = width;
		}
		
	} 
	
}); // mousemove

//if the mouse is upped anywhere
$(document).on("mouseup touchend", function(ev) {
	
	_mouseDown = false;
	_mouseDownXOffset = 0;
	_mouseDownYOffset = 0;	
	_addedControl = false;
	_reorderDetails = null;
	_propertiesPanelSize = false;
	_dialogueSize = false;
	
	if (_controlPanelSize) {
		
		// only if the panel is pinned
		if (_panelPinnedOffset > 0) {
			// set the latest panel pinned offset (plus padding and border)
			_panelPinnedOffset = $("#controlPanel").width() + 21;
			// size the window
			windowResize("controlPanelSize");			
		}
		// set to false
		_controlPanelSize = false;
		// arrange controls as  the left reference has changed
		arrangeNonVisibleControls();
		
	} 
	
	// if we were moving an action restore it's z-index
	if (_movingAction) $("#" + _movingAction).css("z-index","4");
	
}); // mouseup

// called whenever the page is resized
function windowResize(ev) {

	// get the caller of this function
	var caller = ev.data || ev;
	
	// get the window width
	var width = _window.width();
		
	// get the current scroll position
	var scrollTop = _window.scrollTop();
	
	// get the control panel
	var controlPanel = $("#controlPanel");		
	// set it's height to auto
	controlPanel.css("height","auto");
	
	// get the properties panel
	var propertiesPanel = $("#propertiesPanel");
	// set it's height to auto
	propertiesPanel.css("height","auto");
	
	// use the function to get our working height
	var height = getHeight();
				
	// adjust controlPanel height, less it's padding
	controlPanel.css({height: height - 20});
	
	// adjust propertiesPanel height, less it's padding
	propertiesPanel.css({height: height - 20});
								
	// get the control inner
	var cinner = $("#controlPanelInner");
	// if height is less than window
	if (cinner.height() < _window.height()) {
		// fix the position and set the width
		cinner.css({
			"position":"fixed",
			"width": $("#controlPanel").width()
			});
		// reset pin
		$("#controlPanelPin").css({"top":"0", "right":"0"});
	} else {
		// set it to the default, static, so it scrolls
		cinner.css("position","static");
		// adjust pin
		$("#controlPanelPin").css({"top":controlPanel.css("padding-top"), "right":controlPanel.css("padding-right")});
	}
	
	// get the properties inner
	var pinner = $("#propertiesPanelInner");
	// if height is less than window
	if (pinner.height() < _window.height()) {
		// fix the position and set the width
		pinner.css({
			"position":"fixed",
			"width": $("#propertiesPanel").width()
			});
		// reset pin
		$("#propertiesPanelPin").css({"top":controlPanel.css("padding-top"), "left":"0"});
	} else {
		// set it to the default, static, so it scrolls
		pinner.css("position","static");
		// adjust pin - note that the height is matched to the padding on the control panel as properties has no padding top and we want pins on the same level
		$("#propertiesPanelPin").css({"top":controlPanel.css("padding-top"), "left":propertiesPanel.css("padding-left")});
	}
	
	// if the canvas left needs updating
	if (_flowCanvas.css("left") != _panelPinnedOffset) {
		// update the canvas left value
		_flowCanvas.css("left",_panelPinnedOffset);
		// (re)set the container so the connectors are redrawn in the same place
		_jsPlumb.setContainer(_flowCanvas);
	}
	
}

//jsPlumb is ready
jsPlumb.ready( function () {

	// retain reference to instance
	_jsPlumb = jsPlumb.getInstance({
		
        // default drag options
        DragOptions: { cursor: 'pointer', zIndex: 2000 },
        // the overlays to decorate each connection with.  note that the label overlay uses a function to generate the label text; in this
        // case it returns the 'labelText' member that we set on each connection in the 'init' method below.
        ConnectionOverlays: [
            [ "Arrow", {
                location: 1,
                visible:true,
                width:11,
                length:11,
                id:"ARROW",
                events:{
                    click:function() { alert("you clicked on the arrow overlay")}
                }
            } ] /*,
            [ "Label", {
                location: 0.1,
                id: "label",
                cssClass: "aLabel",
                events:{
                    tap:function() { alert("hey"); }
                }
            }] */
        ],
        Container: "canvas"
    });
	
	// this is the paint style for the connecting lines..
    var connectorPaintStyle = {
        strokeWidth: 2,
        stroke: "#61B7CF",
        joinstyle: "round",
        outlineStroke: "white",
        outlineWidth: 2
    },
    // .. and this is the hover style.
    connectorHoverStyle = {
        strokeWidth: 3,
        stroke: "#216477",
        outlineWidth: 5,
        outlineStroke: "white"
    },
    endpointHoverStyle = {
        fill: "#216477",
        stroke: "#216477"
    },
    initConnection = function (connection) {
         connection.getOverlay("label").setLabel(connection.sourceId + "-" + connection.targetId);         
    };
	
	// the definition of source endpoints
    _sourceEndpoint = {
        endpoint: "Dot",
        paintStyle: {
            stroke: "#7AB02C",
            fill: "white",
            radius: 7,
            strokeWidth: 1
        },
        isSource: true,
        connector: [ "Flowchart", { stub: [40, 60], gap: 10, cornerRadius: 5, alwaysRespectStubs: true } ],
        connectorStyle: connectorPaintStyle,
        hoverPaintStyle: endpointHoverStyle,
        connectorHoverStyle: connectorHoverStyle,
        dragOptions: {}/*,
        overlays: [[ "Label", { location: [0.5, 1.5], label: "Drag", cssClass: "endpointSourceLabel", visible: true } ]]
        */
    };
	
    // the definition of target endpoints (will appear when the user drags a connection)
     _targetEndpoint = {
         endpoint: "Dot",
         paintStyle: { fill: "#7AB02C", radius: 7 },
         hoverPaintStyle: endpointHoverStyle,
         maxConnections: 1,
         dropOptions: { hoverClass: "hover", activeClass: "active" },
         isTarget: true/*,
         overlays: [[ "Label", { location: [0.5, -0.5], label: "Drop", cssClass: "endpointTargetLabel", visible: true } ]]
         */
     };

	// basic connector type
    var basicType = {
        connector: "StateMachine",
        paintStyle: { stroke: "red", strokeWidth: 4 },
        hoverPaintStyle: { stroke: "blue" },
        overlays: [ "Arrow" ]
    };
	// register the basic type
    _jsPlumb.registerConnectionType("basic", basicType);
        
    // suspend drawing and initialise.
    _jsPlumb.batch( function () {

        // listen for new connections; initialise them the same way we initialise the connections at startup.
        _jsPlumb.bind("connection", function (connInfo, originalEvent) {
        	//initConnection(connInfo.connection);
        });
        
        // listen for clicks on connections, and offer to delete connections on click.
        _jsPlumb.bind("click", function (conn, originalEvent) {
           if (confirm("Delete connection from " + conn.sourceId + " to " + conn.targetId + "?")) instance.detach(conn);
        });

        _jsPlumb.bind("connectionDrag", function (connection) {
            console.log("connection " + connection.id + " is being dragged. suspendedElement is ", connection.suspendedElement, " of type ", connection.suspendedElementType);
        });

        _jsPlumb.bind("connectionDragStop", function (connection) {
            console.log("connection " + connection.id + " was dragged");
        });

        _jsPlumb.bind("connectionMoved", function (params) {
            console.log("connection " + params.connection.id + " was moved");
        });
        
        _jsPlumb.bind("connectionMoved", function (params) {
            console.log("connection " + params.connection.id + " was moved");
        });
                  
    });
	
});

//anchor positions
var _anchorPositions = [["BottomCenter"],["LeftMiddle", "RightMiddle"],["LeftMiddle", "BottomCenter", "RightMiddle"]];

// add a new flow action
function addFlowAction(id, left, top, type) {
	// get the action type
	var a = _actionTypes[type];
	// add the html
	_flowCanvas.append("<div class='action jtk-node' id='" + id +  "'' style='top:" + top + "px;left:" + left + "px'><span>" + a.name +  "</span></div>");
	// get a reference to the element
	var e = $("#" + id);
	// make it draggable
    _jsPlumb.draggable(e);
	// add target (input)
    _jsPlumb.addEndpoint(id, _targetEndpoint, { anchor: "TopCenter", uuid: id + "I" });
    // assume no outputs
    var outputs = [];
    // loop the properties
    for (var i in a.properties.property) {
    	// get property
    	var p = a.properties.property[i];
    	// if this is a work flow output add to outputs
    	if (p.workflowOutput) outputs.push(p);
    }
    // if no specified outputs
    if (outputs.length == 0) {
    	// add single output
    	_jsPlumb.addEndpoint(id, _sourceEndpoint, { anchor: _anchorPositions[0][i], uuid: id + "O" });
    } else {
    	// loop outputs
    	for (var i in outputs) {
    		_jsPlumb.addEndpoint(id, _sourceEndpoint, { anchor: _anchorPositions[outputs.length -1][i], uuid: id + outputs[i].key }).bind("mouseover", function(endpoint) {
    		    console.log("you clicked on ", endpoint);
    		})
    	}
    }
	// retain this in the flow
    _flow[id] = {id:id,type:type};
    // add a click listener to show the properties
    e.click( function(ev){
    	// get the action
    	var a = _flow[$(ev.target).attr("id")];
    	// show it's properties
    	showActionProperties(a);
    	showPropertiesPanel();
    });
}

function addFlowOutput(from, to) {
	// connect detailed from to single input
	_jsPlumb.connect({ uuids: [from, to], editable: true  });
}

// this supports the getDataOptions function in properties.js
function getControls() {
	return null;
}

//this renders all the control properties in the properties panel
function showActionProperties(action) {
		
	// remove all listeners for this panel
	removeListeners("propertiesPanel");
		
	// grab a reference to the properties div
	var propertiesPanel = $(".propertiesPanelDiv");
		
	// if there was a control
	if (action) {
		
		// get the action class
		var actionClass = _actionTypes[action.type];
	
		// empty the properties
		propertiesPanel.html("");
		// add the help hint
		addHelp("helpProperties",true);
		// add a header toggle
		propertiesPanel.find("h2").click( toggleHeader );

		// append a table
		propertiesPanel.append("<table class='propertiesPanelTable'><tbody></tbody></table>");		
		// get a reference to the table
		var propertiesTable = propertiesPanel.children().last().children().last();
		// add the properties header
		propertiesTable.append("<tr><td class='propertyHeader'><h3>" + actionClass.name + "</h3></td><td>&nbsp;</tr></tr>");
		// if there is helpHtml
		if (actionClass.helpHtml) {
			// add a help icon after the title
			propertiesTable.find("h3").after("<img id='" + action.id + "help' class='controlHelp' src='images/help_16x16.png' />");
			// add the help listener
			addHelp(action.id + "help",true,true,actionClass.helpHtml);
		}
		// add a small break
		propertiesTable.append("<tr><td colspan='2'></td></tr>");
		// show the control id if requested
		if (_version.showControlIds) propertiesTable.append("<tr><td>ID</td><td class='canSelect'>" + action.id + "</td></tr>");
		// check there are class properties
		var properties = actionClass.properties;
		if (properties) {
			// (if a single it's a class not an array due to JSON class conversion from xml)
			if ($.isArray(properties.property)) properties = properties.property; 			
			// loop the class properties
			for (var i in properties) {
				// add a row
				propertiesTable.append("<tr></tr>");
				// get a reference to the row
				var propertiesRow = propertiesTable.children().last();
				// retrieve a property object from the control class
				var property = properties[i];
				// check that visibility is not false
				if (property.visible === undefined || !property.visible === false) {
					// assume no help
					var help = "";
					// if the property has help html
					if (property.helpHtml) {
						// make the helpId
						var helpId = action.id + property.key + "help";
						// create help html
						help = "<img id='" + helpId + "' class='propertyHelp' src='images/help_16x16.png' />"						
					}
					// get the property itself from the control
					propertiesRow.append("<td>" + property.name + help + "</td><td></td>");
					// add the help listener
					if (help) addHelp(helpId,true,true,property.helpHtml);
					// get the cell the property update control is going in
					var cell = propertiesRow.children().last();
					// apply the property function if it starts like a function or look for a known Property_[type] function and call that
					if (property.changeValueJavaScript.trim().indexOf("function(") == 0) {
						try {
							var changeValueFunction = new Function(property.changeValueJavaScript);
							changeValueFunction.apply(this,[cell, control, property]);
						} catch (ex) {
							alert("Error - Couldn't apply changeValueJavaScript for " + action.name + "." + property.name + " " + ex);
						}
					} else {
						if (window["Property_" + property.changeValueJavaScript]) {
							window["Property_" + property.changeValueJavaScript](cell, action, property);
						} else {
							alert("Error - There is no known Property_" + property.changeValueJavaScript + " function");
						}
					}
				}			
			} // visible property
			
		} // got properties
		
	} // got control
	
	// set the parent height to auto
	propertiesPanel.parent().css("height","auto");
		
}

